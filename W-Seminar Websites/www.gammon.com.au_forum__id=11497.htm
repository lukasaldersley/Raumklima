<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> 

<html>

<!-- This document is hand-crafted in HTML by Nick Gammon -->

<head>


<meta name="google-site-verification" content="KptDUaIc-O_rfvV30ttczn66Zg6fL9UWq1fVovU8RGs" />

<title>Gammon Forum : Electronics : Microprocessors : Power saving techniques for microprocessors</title>

<meta name=description content="Gammon Forum : Electronics : Microprocessors : Power saving techniques for microprocessors">
<meta name=keywords content="forum, topics, subjects">
<link rel="alternate" type="application/rss+xml" 
  href="/rss/forum.xml" title="Forum RSS Feed">

<link type="text/css" rel="stylesheet" href="/style.css?v=11">

<meta name="viewport" content="width=device-width, initial-scale=1.0">


<style type="text/css">
  body {color:black; }
  body {background-color: #F5F5F5; }
</style>


</head>

<body>

<a href="/welcome.html"><img alt="[Home]" border=0 height=27 src="/images/home.gif" width=95></a>

<a href="/downloads.htm"><img alt="[Downloads]" border=0 height=27 src="/images/downloads.gif" width=95></a> 

<a href="/search.htm"><img src="/images/search.gif" alt="[Search]" width=95 height=27 border=0></a> 

<a href="/forum/"><img src="/images/forum.gif" alt="[Help/forum]" width=95 height=27 border=0></a> 

<br>
<hr>


<style>
@media screen and (min-width: 600px) {
    .indented {
        margin-left: 3em;
        margin-right: 3em;
    }
}
</style>

<div class=indented><a name=top></a>

  <form METHOD="post" ACTION="//www.gammon.com.au/forum/bbshowpost.php">
    <table border="0" width="100%">
    <tr valign="top">
      <td align="left">
        <h3>Gammon Forum</h3>
<p style="font-size:small;">
See <a href="//www.mushclient.com/spam">www.mushclient.com/spam</a> for dealing with forum spam.
Please read the <a href="//mushclient.com/faq">MUSHclient FAQ</a>! 
</p><img src="/images/open_folder.gif" width="15" height="15" border="0" alt="[Folder]"/>
&nbsp;<b><a href="//www.gammon.com.au/forum/bbshowpost.php">Entire forum</a>
</b><br>
<img src="/images/bar.gif" width="15" height="15" border="0" alt="-&gt;"/>
<img src="/images/open_folder.gif" width="15" height="15" border="0" alt="[Folder]"/>
&nbsp;<b><a href="//www.gammon.com.au/forum/bbshowpost.php?bbsection_id=14">Electronics</a>
</b><br>
<img src="/images/blank.gif" width="15" height="15" border="0" alt="."/>
<img src="/images/bar.gif" width="15" height="15" border="0" alt="-&gt;"/>
<img src="/images/open_folder.gif" width="15" height="15" border="0" alt="[Folder]"/>
&nbsp;<b><a href="//www.gammon.com.au/forum/bbshowpost.php?bbtopic_id=123">Microprocessors</a>
</b><br>
<img src="/images/blank.gif" width="15" height="15" border="0" alt="."/>
<img src="/images/blank.gif" width="15" height="15" border="0" alt="."/>
<img src="/images/bar.gif" width="15" height="15" border="0" alt="-&gt;"/>
<img src="/images/open_subject.gif" width="15" height="15" border="0"  alt="[Subject]"/>
&nbsp;<b>Power saving techniques for microprocessors</b><br>
      </td>
      <td align="right">
        <table border="0" >
          <tr align="right">
          <td colspan="2">
            <font size="1">
            <a href="//www.gammon.com.au">Home</a>
&nbsp;|&nbsp;
<a href="//www.gammon.com.au/forum/bbuserlist.php">Users</a>
&nbsp;|&nbsp;
<a href="//www.gammon.com.au/forum/bbsearch.php">Search</a>
&nbsp;|&nbsp;
<a href="/forum/bbshowpost.php?bbsection_id=4">FAQ</a>
            </font>
          </td>
          </tr>
          <tr align="right">
          <th ><font size="1">Username:</font></th>
          <td >
            <font size="1"><input type="text" name="username" size="20" maxlength="40" tabindex=1
            value=""/><br>
            <a href="//www.gammon.com.au/forum/bbuseredit.php" target="_blank">Register forum user name</a>
            </font>
         </td>
        </tr>
        <tr align="right">
            <th><font size="1">Password:</font></th>
            <td>
            <font size="1"><input type="password" name="password" size="20" tabindex=2 maxlength="40"/><br>
            <a href="//www.gammon.com.au/forum/bbpassword.php?action=forgot" target="_blank">Forgotten password?</a>
            </font>
          </td>
        </tr>
        <tr align="right">
          <td colspan="2">
          <input Type="submit" Value="Log on"/>
          <input type="hidden" name="action" value="logon"/>
          </td>
        </tr>


        </table>
      </td>
    </tr>
    </table>
  <input type="hidden" name="bbsection_id" value="14"/>
<input type="hidden" name="bbtopic_id" value="123"/>
<input type="hidden" name="bbsubject_id" value="11497"/>
</form>
<hr>
<table border=0 cellpadding=5 bgcolor="#CD5C5C" width="100%">
<tr bgcolor="#CD5C5C" align=center>
<th><font color="#FFFFFF">
<b>Power saving techniques for microprocessors</b>
</font></th></tr>
</table>
<p>
<p><b>Postings by administrators only.</b></p>
<a href="//www.gammon.com.au/forum/bbshowpost.php?bbsubject_id=11497&amp;page=1" rel="nofollow"><img src="/images/refresh.gif" alt="[Refresh]" width="13" height="16" border="0"/>&nbsp;Refresh page</a>
</p><hr>
<a name="reply0"></a><a name="70131"></a>
<table border=0 cellpadding=5 width="100%">
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Posted by</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><b>Nick Gammon</b></a>
<font size=1>&nbsp;&nbsp;Australia</font>&nbsp;&nbsp;<font size=1>(21,244 posts)</font>&nbsp;&nbsp;<font size=1><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><img src="/images/bio.gif" border=0 width=15 height=15 alt="[Biography]">&nbsp;bio</a>
</font>&nbsp;&nbsp;<font size=1><i>Forum Administrator</i></font></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Date</b></td>
    <td bgcolor="#FAF0E6" align=left>Fri 13 Jan 2012 01:40 AM (UTC)<p><font size=1>Amended on Mon 14 Sep 2015 08:14 PM (UTC) by <a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank">Nick Gammon</a>
</font></p></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Message</b></td>
    <td bgcolor="#FAF0E6" align=left><div class=postbody><table width="100%"><tr><td><div class="heading">Summary</div><br />
<br />
<table class="template"><tr><td>

This page can be quickly reached from the link: <a href="http://www.gammon.com.au/power">http://www.gammon.com.au/power</a>

</td></tr></table><br />
<br />
In this thread I show various power-saving techniques for the Atmega328P processor. <br />
<br />
They include sleep modes, use of power-reduction registers, and other techniques. Applying all of them can result in a current draw as low as approximately 100 nano-amps (100 nA), well below the self-discharge rate of most batteries.<br />
<br />
Proof from the datasheet for the Atmega328P (page 405 of my copy):<br />
<br />
<img src="/images/Arduino/Arduino_low_power.png"><br />
<br />
That is 100 nA at at 25&deg;C running at 3v.<br />
<br />
These techniques would be useful for battery-powered devices where the full power of the processor was only required intermittently, for example a TV remote, calculator, doorbell, or some sort of environmental monitor where you only needed to check things from time to time.<br />
<br />
<div class="heading">Introduction</div><br />
<br />
I am going to explore various power-saving options for running your project, presumably from battery power. Tests will show which options have any effect at all, and which ones have the most effect. <br />
<br />
These examples are specifically for the Atmega328P processor, but the techniques are pretty general.<br />
<br />
<div class="tip"><br />
<b>Summary of methods</b><br />
<br />
Use as many of the techniques listed here as are practical in your application. They are described in further detail below.<br />
<br />
<br /><ul>
<li>Run the processor at a lower frequency<br />
<li>Run the processor at a lower voltage<br />
<li>Turn off unneeded internal modules in software (eg. SPI, I2C, Serial, ADC)<br />
<li>Turn off brownout detection<br />
<li>Turn off the Analog-to-Digital converter (ADC)<br />
<li>Turn off the watchdog timer<br />
<li>Put the processor to sleep<br />
<li>Don&#039;t use inefficient voltage regulators - if possible run directly from batteries<br />
<li>Don&#039;t use power-hungry displays (eg. indicator LEDs, backlit LCDs)<br />
<li>Arrange to wake the processor from sleep only when needed<br />
<li>Turn off (with a MOSFET) external devices (eg. SD cards, temperature sensors) until needed<br />
</ul><br />
</div><br />
<br />
<div class="heading">Baseline - Arduino Uno</div><br />
<br />
As a preliminary baseline test, we&#039;ll put this sketch onto an Arduino Uno Rev 3 board:<br />
<br />
<b>Sketch A</b><br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
void setup () {}
void loop () {}
</code></pre></span></div><br />
<br />
Clearly it doesn&#039;t do much. :)<br />
<br />
Running from a 9V battery through the &quot;power in&quot; plug, it draws about <b>50 mA</b>.<br />
<br />
Running on 5V through the +5V pin, it draws about <b>49 mA</b>.<br />
<br />
(Note: around 68 mA on a Mega 2560 board)<br />
<br />
Now we&#039;ll try putting it to sleep:<br />
<br />
<b>Sketch B</b><br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
#include &lt;avr/sleep.h&gt;

void setup () 
{
  set_sleep_mode (SLEEP_MODE_PWR_DOWN);  
  sleep_enable();
  sleep_cpu ();  
}  // end of setup

void loop () { }
</code></pre></span></div><br />
<br />
Now the Uno draws <b>34.5 mA</b>. A saving, but not a lot.<br />
<br />
(Note: around 24 mA on a Mega 2560 board)<br />
<br />
<div class="heading">Atmega328 processor on its own</div><br />
<br />
Using a &quot;bare bones&quot; board saves quite a bit of power.<br />
<br />
<img src="/images/Wire_Wrapped_Atmega132_a.jpg"><br />
<br />
<i>Bare-bones board.</i><br />
<br />
Sketch A above only draws <b>15.15 mA</b>, a saving of 34.85 mA just by not using the development board. This would be accounted for by the fact that the development board has on it:<br />
<br />
<br /><ul>
<li>Voltage regulators (for +5V and +3.3V)<br />
<li>A USB interface chip (for the USB port)<br />
<li>A &quot;power&quot; LED<br />
</ul><br />
<br />
Sketch B above only draws <b>360 &micro;A</b> (<b>0.360 mA</b>) which is a LOT less. Still, you would expect about 31 mA less than the figure above for the Uno, so that sounds about right.<br />
<br />
Also, with low power consumption I can put the multimeter on the &quot;microamps&quot; range which is more sensitive.<br />
<br />
The initial outcome is that, to save power, forget about using a development board. Further savings (like reducing clock speed) would be overshadowed by the huge overhead of the voltage regulator and USB interface chip.<br />
<br />
So from now on I&#039;ll experiment with the &quot;bare bones&quot; board. However it can still be programmed using the normal Arduino IDE (Integrated Development Environment). In my case I am using the USBtinyISP programming gadget, which you can get from here for around $US 22.<br />
<br />
<code>http://www.ladyada.net/make/usbtinyisp/</code><br />
<br />
To program the board I changed a line in the Arduino preferences.txt file, as follows:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
upload.using=<b>usbtinyisp</b>
</code></pre></span></div><br />
<br />
The &quot;bare bones&quot; board I am playing with is from &quot;Evil Mad Science&quot; for around $US 13 for the board, processor chip, a ZIF (zero insertion force) socket, a 6-pin programming header, and a couple of other things:<br />
<br />
<code>http://evilmadscience.com/productsmenu/tinykitlist/230</code><br />
<br />
<img src="/images/BareBones_11497.png"><br />
<br />
<i>The &quot;Evil Mad Scientist&quot; board. This particular one does not have the ZIF socket.</i><br />
<br />
<div class="heading">Different sleep modes</div><br />
<br />
Let&#039;s substitute the various sleep modes in this line:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
  set_sleep_mode (SLEEP_MODE_PWR_DOWN);  
</code></pre></span></div><br />
<br />
<b>Sleep modes and power consumption:</b><br />
<br />
<br /><ul>
<li>SLEEP_MODE_IDLE: <b>15 mA</b><br />
<li>SLEEP_MODE_ADC: <b>6.5 mA</b><br />
<li>SLEEP_MODE_PWR_SAVE: <b>1.62 mA</b><br />
<li>SLEEP_MODE_EXT_STANDBY: <b>1.62 mA</b><br />
<li>SLEEP_MODE_STANDBY : <b>0.84 mA</b><br />
<li>SLEEP_MODE_PWR_DOWN : <b>0.36 mA</b><br />
</ul><br />
<br />
Power-save mode lets you keep Timer 2 running (providing clocked from an external source). <br />
<br />
Stand-by mode is similar to power-down mode, except that the oscillator is kept running. This lets it wake up faster.<br />
<br />
<b>Note:</b> In IDLE mode, the clocks are running. This means that (unless you disable it) the normal Timer 0 clock used to count millis() will be running, and thus you will wake up approximately every millisecond.<br />
<br />
<br />
<div class="heading">Brown-out disable</div><br />
<br />
Another power saving can be made by disabling the brown-out detection. To detect low voltages the processor must generate a voltage source for comparison purposes. You can change the &quot;extended fuse&quot; (efuse) by using AVRdude, like this:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
avrdude -c usbtiny -p m328p -U efuse:w:0x07:m
</code></pre></span></div><br />
<br />
In SLEEP_MODE_PWR_DOWN mode, with brown-out disabled, the power went down from <b>360 &micro;A</b> to <b>335 &micro;A</b>, a saving of 25 &micro;A.<br />
<br />
Another way of turning off brown-out detection is to temporarily disable it like this:<br />
<br />
<b>Sketch C</b><br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
#include &lt;avr/sleep.h&gt;

void setup () 
{
  set_sleep_mode (SLEEP_MODE_PWR_DOWN);  
  noInterrupts ();           // timed sequence follows
  sleep_enable();
 
  // turn off brown-out enable in software
  MCUCR = bit (BODS) | bit (BODSE);  // turn on brown-out enable select
  MCUCR = bit (BODS);        // this must be done within 4 clock cycles of above
  interrupts ();             // guarantees next instruction executed
  sleep_cpu ();              // sleep within 3 clock cycles of above
}  // end of setup

void loop () { }
</code></pre></span></div><br />
<br />
Note that this is a timed sequence. You must do sleep_cpu() directly after the bit manipulation or the brown-out disable is cancelled.<br />
<br />
<div class="heading">Turn off ADC (analog to digital conversion)</div><br />
<br />
Next thing we can do turn off the ADC subsystem by adding this line:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
  // disable ADC
  ADCSRA = 0;  
</code></pre></span></div><br />
<br />
With that there the power consumption drops a large amount, down from <b>335 &micro;A</b> to <b>0.355 &micro;A</b>! (that is, <b>355 nA</b>)<br />
<br />
<br />
<div class="heading">Configuring pins as inputs/outputs</div><br />
<br />
Let&#039;s experiment with configuring the pins in various ways ...<br />
<br />
<b>Sketch D</b><br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
#include &lt;avr/sleep.h&gt;

void setup () 
{

  for (byte i = 0; i &lt;= A5; i++)
    {
    pinMode (i, OUTPUT);    // changed as per below
    digitalWrite (i, LOW);  //     ditto
    }
    
  // disable ADC
  ADCSRA = 0;  
  
  set_sleep_mode (SLEEP_MODE_PWR_DOWN);  
  noInterrupts ();           // timed sequence follows
  sleep_enable();
 
  // turn off brown-out enable in software
  MCUCR = bit (BODS) | bit (BODSE);
  MCUCR = bit (BODS); 
  interrupts ();             // guarantees next instruction executed
  sleep_cpu ();              // sleep within 3 clock cycles of above

}  // end of setup

void loop () { }
</code></pre></span></div><br />
<br />
Testing in SLEEP_MODE_PWR_DOWN:<br />
<br />
<br /><ul>
<li><b>All pins as outputs, and LOW</b>: <b>0.35 &micro;A</b> (same as before).<br />
<br />
<li><b>All pins as outputs, and HIGH</b>: <b>1.86 &micro;A</b>.<br />
<br />
<li><b>All pins as inputs, and LOW</b> (in other words, internal pull-ups disabled): <b>0.35 &micro;A</b> (same as before).<br />
<br />
<li><b>All pins as inputs, and HIGH</b> (in other words, internal pull-ups enabled): <b>1.25 &micro;A</b>.<br />
</ul><br />
<br />
<b>Note:</b> This was tested with nothing connected to the pins. Obviously if you have an LED or something like that on an output pin, you will draw more current.<br />
<br />
<br />
<div class="heading">Power Reduction Register (PRR)</div><br />
<br />
The next thing to experiment with is the Power Reduction Register (PRR). This lets you &quot;turn off&quot; various things inside the processor.<br />
<br />
The various bits in this register turn off internal devices, as follows:<br />
<br />
<br /><ul>
  <li> Bit 7 - PRTWI: Power Reduction TWI<br />
  <li> Bit 6 - PRTIM2: Power Reduction Timer/Counter2<br />
  <li> Bit 5 - PRTIM0: Power Reduction Timer/Counter0<br />
  <li> Bit 4 - Res: Reserved bit<br />
  <li> Bit 3 - PRTIM1: Power Reduction Timer/Counter1<br />
  <li> Bit 2 - PRSPI: Power Reduction Serial Peripheral Interface<br />
  <li> Bit 1 - PRUSART0: Power Reduction USART0<br />
  <li> Bit 0 - PRADC: Power Reduction ADC<br />
</ul><br />
<br />
<div class="tip"><br />
<b>Tip:</b><br />
  The macros power_all_disable() and power_all_enable() modify the PRR register as appropriate for different processors.<br />
</div><br />
<br />
<b>Sketch E</b><br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
#include &lt;avr/sleep.h&gt;
#include &lt;avr/power.h&gt;

void setup () 
{

  // disable ADC
  ADCSRA = 0;  

  // turn off various modules
  power_all_disable ();
  
  set_sleep_mode (SLEEP_MODE_IDLE);  
  noInterrupts ();           // timed sequence follows
  sleep_enable();
 
  // turn off brown-out enable in software
  MCUCR = bit (BODS) | bit (BODSE);
  MCUCR = bit (BODS); 
  interrupts ();             // guarantees next instruction executed
  sleep_cpu ();              // sleep within 3 clock cycles of above    
}  // end of setup

void loop () { }
</code></pre></span></div><br />
<br />
<b>Important note!</b> You must use the PRR <b>after</b> setting ADCSRA to zero, otherwise the ADC is &quot;frozen&quot; in an active state.<br />
<br />
<b>Sketch F</b><br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
#include &lt;avr/power.h&gt;

void setup () 
{
  power_all_disable();  // turn off all modules
}  // end of setup

void loop () { }
</code></pre></span></div><br />
<br />
<br />
<b>Sketch G</b><br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
#include &lt;avr/power.h&gt;

void setup () 
{
  ADCSRA = 0;  // disable ADC
  power_all_disable ();   // turn off all modules
}  // end of setup

void loop () { }
</code></pre></span></div><br />
<br />
<br />
According to the datasheet the PRR only applies in active (non-sleep) and idle modes. In other modes, those modules are already turned off.<br />
<br />
<b>Sleep modes and power consumption with PRR = 0xFF:</b><br />
<br />
<br /><ul>
<li>SLEEP_MODE_IDLE (Sketch E): <b>7.4 mA</b> (was <b>15 mA</b>)<br />
<li>Not sleeping (Sketch F): <b>14 mA</b> (was <b>16.1 mA</b>)<br />
<li>Not sleeping, no ADC (Sketch G): <b>13.6 mA</b> (was <b>16.1 mA</b>)<br />
</ul><br />
<br />
<b>Turning on or off selected modules</b><br />
<br />
Various macros (they vary by processor) let you power on or off individual modules:<br />
<br />
<i>Enabling:</i><br />
<br />
<br /><ul>
<li> power_adc_enable();    // ADC converter<br />
<li> power_spi_enable();    // SPI<br />
<li> power_usart0_enable(); // Serial (USART)<br />
<li> power_timer0_enable(); // Timer 0<br />
<li> power_timer1_enable(); // Timer 1<br />
<li> power_timer2_enable(); // Timer 2<br />
<li> power_twi_enable();    // TWI (I2C)<br />
</ul> <br />
<br />
<i>Disabling:</i><br />
<br />
<br /><ul>
<li> power_adc_disable();   // ADC converter<br />
<li> power_spi_disable();   // SPI<br />
<li> power_usart0_disable();// Serial (USART) <br />
<li> power_timer0_disable();// Timer 0<br />
<li> power_timer1_disable();// Timer 1<br />
<li> power_timer2_disable();// Timer 2<br />
<li> power_twi_disable();   // TWI (I2C)<br />
</ul> <br />
<br />
<div class="heading">Using the internal clock</div><br />
<br />
By changing the fuse bits the processor can run on its 8 MHz internal clock. Running Sketch A above, with lfuse set to 0xE2, the board consumed <b>11.05 mA</b> (compared to <b>15.15 mA</b> using the crystal).<br />
<br />
You can change the clock like this:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
avrdude -c usbtiny -p m328p -U lfuse:w:0xE2:m
</code></pre></span></div><br />
<br />
Another way of changing the clock speed is to enable the &quot;divide clock by 8&quot; fuse bit. So this gives you various other options, like a 16 MHz crystal divided by 8 giving 2 MHz, or the internal 8 MHz oscillator, divided by 8, giving 1 Mhz.<br />
<br />
You can also run the processor on a low-power 128 KHz internal clock. Running Sketch A above, with lfuse set to 0xE3, the board consumed <b>6 mA</b> (compared to <b>16.1 mA</b> using the crystal).<br />
<br />
Note that using the slower clock doesn&#039;t really help in sleep mode, because the clock is stopped anyway.<br />
<br />
<b>Warning:</b> Once the clock is set to 128 KHz, you will have trouble programming the board. You need to add -B250 to the AVRdude command line. For example, to put the clock back to using the crystal:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
avrdude -c usbtiny -p m328p -U lfuse:w:0xFF:m <b>-B250</b>
</code></pre></span></div><br />
<br />
There is a fuse calculator for boards here:<br />
<br />
<code>http://www.engbedded.com/fusecalc</code><br />
<br />
<b>Another warning:</b> Pay close attention to the fuse bit settings. If you get them wrong you can &quot;brick&quot; your processor. It can be recovered with a high-voltage programmer like the AVR Dragon, if you have one handy. In particular you don&#039;t want to turn off SPIEN (Enable Serial programming and Data Downloading). Nor do you want to turn on RSTDISBL (External reset disable).<br />
<br />
<b>Summary of clock speeds and current</b><br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
<b>lfuse   Speed    Current</b>
0xFF    16 MHz    15.15 mA
0xE2     8 MHz    11.05 mA
0x7F     2 MHz     7.21 mA
0x62     1 MHz     6.77 mA
0xE3   128 KHz     6.00 mA 
</code></pre></span></div><br />
<br />
Another point is that running from a slower clock means, that if you sleep and wake, you are awake for longer (potentially 16 times as long if you cut a 16 MHz processor down to 1 MHz). So if you consume more power when awake, and are awake for much longer, then that can outweigh the savings from running at slower speeds.<br />
<br />
<div class="heading">Waking from sleep with a timer</div><br />
<br />
Well, this sleeping as all very well, but a processor that stays asleep isn&#039;t particularly useful. Although, I <b>have</b> seen an example of that: the TV Begone remote control. What that does is send out some codes (to turn TVs off) and then goes to sleep permanently. The &quot;activate&quot; button on the gadget is the reset button. When you press that it does its stuff again.<br />
<br />
Meanwhile this sketch below shows how you can use the watchdog timer to sleep for 8 seconds (the maximum you can set up a watchdog for) and then flash the LED 10 times, and go back to sleep. Whilst asleep it uses about <b>6.54 &micro;A</b> of current, so presumably the watchdog timer has a bit of an overhead (like, <b>6.2 &micro;A</b>).<br />
<br />
<b>Sketch H</b><br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
#include &lt;avr/sleep.h&gt;
#include &lt;avr/wdt.h&gt;

const byte LED = 9;

void flash ()
  {
  pinMode (LED, OUTPUT);
  for (byte i = 0; i &lt; 10; i++)
    {
    digitalWrite (LED, HIGH);
    delay (50);
    digitalWrite (LED, LOW);
    delay (50);
    }
    
  pinMode (LED, INPUT);
    
  }  // end of flash
  
// watchdog interrupt
ISR (WDT_vect) 
{
   wdt_disable();  // disable watchdog
}  // end of WDT_vect
 
void setup () { }

void loop () 
{
 
  flash ();
  
  // disable ADC
  ADCSRA = 0;  

  // clear various &quot;reset&quot; flags
  MCUSR = 0;     
  // allow changes, disable reset
  WDTCSR = bit (WDCE) | bit (WDE);
  // set interrupt mode and an interval 
  WDTCSR = bit (WDIE) | bit (WDP3) | bit (WDP0);    // set WDIE, and 8 seconds delay
  wdt_reset();  // pat the dog
  
  set_sleep_mode (SLEEP_MODE_PWR_DOWN);  
  noInterrupts ();           // timed sequence follows
  sleep_enable();
 
  // turn off brown-out enable in software
  MCUCR = bit (BODS) | bit (BODSE);
  MCUCR = bit (BODS); 
  interrupts ();             // guarantees next instruction executed
  sleep_cpu ();  
  
  // cancel sleep as a precaution
  sleep_disable();
  
  } // end of loop
</code></pre></span></div><br />
<br />
This slightly different example shows how you can flash an LED once a second (approximately) and then go to sleep for the rest of the time:<br />
<br />
<b>Sketch I</b><br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
#include &lt;avr/sleep.h&gt;
#include &lt;avr/wdt.h&gt;

const byte LED = 9;
  
// watchdog interrupt
ISR (WDT_vect) 
{
   wdt_disable();  // disable watchdog
}  // end of WDT_vect
 
void setup () { }

void loop () 
{
 
  pinMode (LED, OUTPUT);
  digitalWrite (LED, HIGH);
  delay (50);
  digitalWrite (LED, LOW);
  pinMode (LED, INPUT);
  
  // disable ADC
  ADCSRA = 0;  

  // clear various &quot;reset&quot; flags
  MCUSR = 0;     
  // allow changes, disable reset
  WDTCSR = bit (WDCE) | bit (WDE);
  // set interrupt mode and an interval 
  WDTCSR = bit (WDIE) | bit (WDP2) | bit (WDP1);    // set WDIE, and 1 second delay
  wdt_reset();  // pat the dog
  
  set_sleep_mode (SLEEP_MODE_PWR_DOWN);  
  noInterrupts ();           // timed sequence follows
  sleep_enable();
 
  // turn off brown-out enable in software
  MCUCR = bit (BODS) | bit (BODSE);
  MCUCR = bit (BODS); 
  interrupts ();             // guarantees next instruction executed
  sleep_cpu ();  
  
  // cancel sleep as a precaution
  sleep_disable();
  
  } // end of loop
</code></pre></span></div><br />
<br />
To save you looking up the various combinations of wake-up time here is the table from the datasheet for the Atmega328:<br />
<br />
<img src="/images/Arduino_forum_11497.png"><br />
<br />
Basically you set some of the bits named WDP0 through to WDP3 as per the table, to get different times. Note that the smallest is 16 mS and the longest is 8 S.<br />
<br />
You could arrange longer sleep times by having a &quot;counting&quot; loop and sleep/wake/sleep/wake for x times.<br />
<br />
Note that the watchdog timer is independent of the clock speed of the processor, so an 8-second watchdog timer is still that, regardless of what speed you are clocking the processor at.<br />
<br />
<b>Warning about wake-up times</b><br />
<br />
Various fuse settings make a big difference to the wake-up time. Some wake-up times are quite long (eg. 65 mS) because they are designed to allow the crystal clock to settle. If you are trying to save power, taking 65 mS to wake up, add 1 to a counter, and go back to sleep, is a lot. You would want to look at a &quot;wake-up&quot; fuse setting that is appropriate for the type of clock source you are using.<br />
<br />
Note that if you disable brown-out detection <b>in software</b> rather than by changing the fuse settings then it takes around 60 &micro;s longer to wake up, as mentioned in the datasheet:<br />
<br />
<div class="quote">
<b>Quote:</b><br><br />
If BOD is disabled in software, the BOD function is turned off immediately after entering the sleep mode. Upon wake-up from sleep, BOD is automatically enabled again.<br />
...<br />
When the BOD has been disabled, the wake-up time from sleep mode will be approximately 60 &mu;s to ensure that the BOD is working correctly before the MCU continues executing code.<br />
</div><br />
<br />
For a fast wake-up (which means you get on with what you want to do more quickly) disable brown-out detection by <i>altering the fuses</i>. That&#039;s assuming you <b>want</b> to disable brown-out detection.<br />
<br />
<br />
<div class="heading">Waking from sleep with a signal</div><br />
<br />
Another way of waking from sleep is to detect a logic level change on an interrupt pin (D2 or D3 on the Arduino). These are processor pins 4 and 5 on the actual Atmega328 chip.<br />
<br />
Any interrupt will wake the processor, as this sketch demonstrates. When asleep it uses <b>0.15 &micro;A</b> of current.<br />
<br />
<b>Sketch J</b><br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>

#include &lt;avr/sleep.h&gt;

const byte LED = 9;
  
void wake ()
{
  // cancel sleep as a precaution
  sleep_disable();
  // precautionary while we do other stuff
  detachInterrupt (0);
}  // end of wake

void setup () 
  {
  digitalWrite (2, HIGH);  // enable pull-up
  }  // end of setup

void loop () 
{
 
  pinMode (LED, OUTPUT);
  digitalWrite (LED, HIGH);
  delay (50);
  digitalWrite (LED, LOW);
  delay (50);
  pinMode (LED, INPUT);
  
  // disable ADC
  ADCSRA = 0;  
  
  set_sleep_mode (SLEEP_MODE_PWR_DOWN);  
  sleep_enable();

  // Do not interrupt before we go to sleep, or the
  // ISR will detach interrupts and we won&#039;t wake.
  noInterrupts ();
  
  // will be called when pin D2 goes low  
  attachInterrupt (0, wake, FALLING);
  EIFR = bit (INTF0);  // clear flag for interrupt 0
 
  // turn off brown-out enable in software
  // BODS must be set to one and BODSE must be set to zero within four clock cycles
  MCUCR = bit (BODS) | bit (BODSE);
  // The BODS bit is automatically cleared after three clock cycles
  MCUCR = bit (BODS); 
  
  // We are guaranteed that the sleep_cpu call will be done
  // as the processor executes the next instruction after
  // interrupts are turned on.
  interrupts ();  // one cycle
  sleep_cpu ();   // one cycle

  } // end of loop
</code></pre></span></div><br />
<br />
You could combine both methods. That is, have a watchdog, and a logic level change interrupt.<br />
<br />
<br />
<div class="heading">Other power-saving techniques</div><br />
<br />
<br /><ul>
<li>If you must use a voltage regulator, try to find one with a low quiescent current. For example the LM7805 itself consumes around 5 mA, so there isn&#039;t much use putting a lot of effort into saving the last microamp if your voltage regulator consumes 5 mA non-stop. For example, if you use 3 x 1.5V batteries, you should get around 4.5V which would be enough to power a processor without needing a voltage regulator.<br />
<br />
<li>Go easy on &quot;power&quot; LEDs. LEDs can use quite a bit of current (say, <b>10 mA</b>). If possible just flash one briefly rather than have it on all the time, or use a low-power LED. Experimentation shows that flashing an LED for 5 mS to 10 mS is quite noticeable. So, one 10 mS flash per second is only an overhead of one percent.<br />
<br />
<li>If you have an external peripheral (eg. a clock chip) you could &quot;power&quot; it from a digital pin, and then turn it off when not required. For example, the DS1307 clock chip only uses 1.5 mA when active, so that could be powered by a digital pin.<br />
<br />
<li>For higher power devices you could use a MOSFET transistor to turn the current on/off to it as required.<br />
<br />
<li>Run the processor on a lower voltage (eg. 3.3V). For example Sketch H above only uses <b>4.6 &micro;A</b> when asleep, running on 3.3V, compared to <b>6.4 &micro;A</b> at 5V.<br />
<br />
<li>Sleep the processor as much as possible, even if that means sleeping every second. For example I have a GPS clock that sleeps every second, waking just long enough to &quot;tick&quot; the hand around. Every day or so it wakes up for longer, powers up a GPS module, and resynchronizes its internal time with the GPS time.<br />
</ul><br />
<br />
<br />
<div class="heading">Summary of power savings</div><br />
<br />
Figures are the amount saved by each method, in <b>milli</b>amps:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
Bypassing the &quot;power plug&quot;           8.4
Using a &quot;bare bones&quot; board          30.5
Power-down sleep mode               15.7
Use internal clock at 128 KHz       10.1
Use Power Reduction Register (PRR)   7.6
Use internal clock at 8 MHz          5.4
</code></pre></span></div><br />
<br />
In sleep mode, saving in <b>micro</b>amps:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
Turn off ADC converter               334
Disable brown-out detection           25
Set all pins to input and low          2
</code></pre></span></div><br />
<br />
<br />
<div class="heading">Power budgeting</div><br />
<br />
You can work out how long your project will last on a battery by doing a &quot;power budget&quot;. That is, work out the average amount of power consumed. For example, if you use 5 mA for 1% of the time that would be an average of 0.05 mA (assuming that for the remaining 99% of the time you used a tiny amount like 0.35 &micro;A).<br />
<br />
Some typical battery capacities might be, in mA hours:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
CR1212           18
CR1620           68
CR2032          210
NiMH AAA        900
Alkaline AAA   1250
NiMH AA        2400
Alkaline AA    2890
Li-Ion *       4400
</code></pre></span></div><br />
<br />
* Li-Ion batteries come in a wide variety of sizes, this is just an example.<br />
<br />
So for example, running from AAA batteries, drawing an average of 0.05 mA, the device could run for 1250 / 0.05 = 25000 hours (1041 days, or 33 months).<br />
<br />
Also batteries have a self-discharge rate, so you would need to factor that in. The battery may self-discharge faster than your circuit discharges it! See the post further down for a discussion about self-discharge rates.<br />
<br />
<hr/><br />
<br />
Also see this page about interrupts:<br />
<br />
<a href="http://gammon.com.au/interrupts">http://gammon.com.au/interrupts</a><br />
<br />
<hr/><br />
<br />
<b>[EDIT]</b><br />
<br />
Confirmed low-current readings with Dave Jones&#039; uCurrent device:<br />
<br />
<img src="/images/MicroCurrent_Device.jpg"><br />
<br />
Available for $AUD 49.95 (at present) from:<br />
<br />
<code>http://www.eevblog.com/shop/</code><br />
<br />
Warning! It tends to sell out very quickly.</td></tr><tr><td><hr >
<font size=1 color="#808080">- Nick Gammon<br />
<br />
www.gammon.com.au, www.mushclient.com</font></td></tr><tr align=right><td><font size=1><a href="#top"><img src="/images/gototop.gif" alt="[Go to top]" width=15 height=15 border=0>&nbsp;top</a> </font></td></tr></table>
</div></td>
  </tr>
</table>
<hr>
<a name="reply1"></a><a name="70142"></a>
<table border=0 cellpadding=5 width="100%">
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Posted by</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><b>Nick Gammon</b></a>
<font size=1>&nbsp;&nbsp;Australia</font>&nbsp;&nbsp;<font size=1>(21,244 posts)</font>&nbsp;&nbsp;<font size=1><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><img src="/images/bio.gif" border=0 width=15 height=15 alt="[Biography]">&nbsp;bio</a>
</font>&nbsp;&nbsp;<font size=1><i>Forum Administrator</i></font></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Date</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/?id=11497&reply=1#reply1">Reply #1</a> on Fri 13 Jan 2012 11:01 PM (UTC)<p><font size=1>Amended on Sat 23 Aug 2014 05:28 AM (UTC) by <a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank">Nick Gammon</a>
</font></p></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Message</b></td>
    <td bgcolor="#FAF0E6" align=left><div class=postbody><table width="100%"><tr><td><div class="heading">Waking I2C slave from sleep</div><br />
<br />
Below is an example of waking an I2C slave from sleep. First, a master which wants to talk to the slave:<br />
<br />
<b>Master</b><br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
// I2C master

#include &lt;Wire.h&gt;

const byte SLAVE_ADDRESS = 42;

void setup() 
{
  Wire.begin ();
}  // end of setup

void loop() 
{
byte status;

  for (byte i = 1; i &lt;= 10; i++)
    {  
    // wake slave up
    Wire.beginTransmission (SLAVE_ADDRESS);
    Wire.endTransmission ();
    
    delay (5);  // give it time to recover
    
    Wire.beginTransmission (SLAVE_ADDRESS);
    Wire.send (i);
    status = Wire.endTransmission ();  // 0 is OK
    delay (5000);
    } // end of for loop
}  // end of loop
</code></pre></span></div><br />
<br />
The above master sends a number (from 1 to 10) every 5 seconds to a slave at address 42.<br />
<br />
To give the slave time to react to waking up it first does a beginTransmission/endTransmission pair, which just causes the slave to wake. Then it waits briefly for the slave&#039;s clock to stabilize, and then sends the &quot;real&quot; message.<br />
<br />
<hr/><br />
<br />
<b>Slave</b><br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
// I2C slave that sleeps

#include &lt;Wire.h&gt;
#include &lt;avr/sleep.h&gt;

const byte MY_ADDRESS = 42;
const byte AWAKE_LED = 8;
const byte GREEN_LED = 9;
const unsigned long WAIT_TIME = 500;

volatile byte flashes;
volatile unsigned long counter;

void setup() 
{
  pinMode (GREEN_LED, OUTPUT);
  pinMode (AWAKE_LED, OUTPUT);
  digitalWrite (AWAKE_LED, HIGH);
  Wire.begin (MY_ADDRESS);
  Wire.onReceive (receiveEvent);
  
} // end of setup

void loop() 
{
  if (++counter &gt;= WAIT_TIME)
    {
    byte old_ADCSRA = ADCSRA;
    // disable ADC
    ADCSRA = 0;  
    set_sleep_mode (SLEEP_MODE_PWR_DOWN);  
    sleep_enable();
    digitalWrite (AWAKE_LED, LOW);
    sleep_cpu ();      
    digitalWrite (AWAKE_LED, HIGH);
    sleep_disable();
    counter = 0;
    ADCSRA = old_ADCSRA;
    
    // release TWI bus
    TWCR = bit(TWEN) | bit(TWIE) | bit(TWEA) | bit(TWINT);
    
    // turn it back on again
    Wire.begin (MY_ADDRESS);
    }  // end of time to sleep
  
  
  // flash LED x times where x was the number received from the master
  for (byte i = 0; i &lt; flashes; i++)
    {
    digitalWrite (GREEN_LED, HIGH);
    delay (200);  
    digitalWrite (GREEN_LED, LOW);
    delay (200);  
    }
    
   flashes = 0;
   
}  // end of loop

void receiveEvent (int howMany)
 {
  counter = 0;
  
  flashes = 0;
  if (Wire.available () &gt; 0)
    flashes = Wire.receive ();
  
  // flush remaining bytes
  while (Wire.available () &gt; 0)
    Wire.receive ();
}  // end of receiveEvent
</code></pre></span></div><br />
<br />
The slave goes to sleep after WAIT_TIME trips around the main loop. This delay allows the master time to wake it, and then, whilst awake, send it the &quot;real&quot; message.<br />
<br />
It also appeared to be necessary to reinitialize the I2C bus after being woken because it didn&#039;t appear to be in a stable state otherwise.<br />
<br />
I have a couple of LEDs there - the &quot;green&quot; one on pin D9 flashes the appropriate number of times. Also there is an &quot;awake&quot; LED which helps debug whether the processor is asleep or awake.<br />
<br />
Whilst asleep, I measured about 0.071 mA (71 &micro;A) of current drawn.</td></tr><tr><td><hr >
<font size=1 color="#808080">- Nick Gammon<br />
<br />
www.gammon.com.au, www.mushclient.com</font></td></tr><tr align=right><td><font size=1><a href="#top"><img src="/images/gototop.gif" alt="[Go to top]" width=15 height=15 border=0>&nbsp;top</a> </font></td></tr></table>
</div></td>
  </tr>
</table>
<hr>
<a name="reply2"></a><a name="70204"></a>
<table border=0 cellpadding=5 width="100%">
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Posted by</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><b>Nick Gammon</b></a>
<font size=1>&nbsp;&nbsp;Australia</font>&nbsp;&nbsp;<font size=1>(21,244 posts)</font>&nbsp;&nbsp;<font size=1><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><img src="/images/bio.gif" border=0 width=15 height=15 alt="[Biography]">&nbsp;bio</a>
</font>&nbsp;&nbsp;<font size=1><i>Forum Administrator</i></font></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Date</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/?id=11497&reply=2#reply2">Reply #2</a> on Wed 25 Jan 2012 05:08 AM (UTC)<p><font size=1>Amended on Sat 26 Sep 2015 08:38 PM (UTC) by <a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank">Nick Gammon</a>
</font></p></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Message</b></td>
    <td bgcolor="#FAF0E6" align=left><div class=postbody><table width="100%"><tr><td><div class="heading">More savings with lower voltages</div><br />
<br />
Running sketch A above, namely:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
void setup () {}
void loop () {}
</code></pre></span></div><br />
<br />
And setting the processor to use the internal 8 MHz clock, like this:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
avrdude -c usbtiny -p m328p -U lfuse:w:0xE2:m
</code></pre></span></div><br />
<br />
Let&#039;s compare the current drawn at various voltages:<br />
<br />
<br /><ul>
<li>5.0V : 11.67 mA<br />
<li>4.5V :  7.74 mA<br />
<li>4.0V :  5.60 mA<br />
<li>3.5V :  4.10 mA<br />
<li>3.3V :  3.70 mA *<br />
<li>3.0V :  3.30 mA<br />
<li>2.8V :  3.00 mA<br />
<li>2.5V :  2.70 mA<br />
<li>2.4V :  2.50 mA<br />
<li>2.3V :  2.40 mA<br />
<li>2.2V :  2.30 mA<br />
<li>2.1V :  2.10 mA<br />
</ul><br />
<br />
Clearly substantial power savings can be made by simply running at a lower voltage, if that is practical. And that is running at 8 MHz and without sleeping!<br />
<br />
* A lot of devices are manufactured today to run at 3.3V, so interfacing with them at that voltage should not be a problem.<br />
<br />
<b>[EDIT]</b> Further tests show that the low currents reported for 3.0V and below were anomalous because the chip was not in fact running. (23 December 2012)<br />
<br />
<b>[EDIT]</b> Further testing again showed this was because brown-out detection was enabled at 2.7V. With that disabled, you can get down to around 2.1V at 8 MHz although 2.4V is the minimum recommended in the datasheet.<br />
<br />
<hr/><br />
<br />
Now if we drop the processor speed down to 128 KHz, like this:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
avrdude -c usbtiny -p m328p -U lfuse:w:0xE3:m
</code></pre></span></div><br />
<br />
Then we get:<br />
<br />
<br /><ul>
<li>2.5V :  0.19 mA<br />
<li>1.8V :  0.14 mA<br />
</ul><br />
<br />
Of course you may not want to run at those voltages, or speeds. But for something like monitoring a water tank level you can see that quite modest power consumptions can be achieved, even without sleeping. Of course, if you sleep as well you can save even more.<br />
<br />
<div class="heading">How many volts per Megaherz?</div><br />
<br />
This chart from the Atmega328 datasheet shows the number of volts required for each speed:<br />
<br />
<img src="/images/Atmega_Speed_Vs_Voltage_11497.png"><br />
<br />
Translated into formulae we see that:<br />
<br />
<br /><ul>
<li>Below 1.8V - cannot operate<br />
<li>Below 4 MHz - use at least 1.8V<br />
<li>Between 4 MHz and 10 MHz you require: Volts = 1.8 + ((M - 4) * 0.15)<br />
(Where M is Megaherz)<br />
<li>Between 10 Mhz and 20 MHz you require: Volts = 2.7 + ((M - 10) * 0.18)<br />
(Where M is Megaherz)<br />
<li>You can supply an absolute maximum of 5.5V<br />
</ul><br />
<br />
Re-arranging the formula to calculate a maximum speed for a given voltage:<br />
<br />
<br /><ul>
<li>From 1.8V to 2.7V: M = 4 + ((V - 1.8) / 0.15)<br />
<li>From 2.7V to 4.5V: M = 10 + ((V - 2.7) / 0.18)<br />
</ul><br />
<br />
For example, if you are planning to run at 2V:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
MHz = 4 + ((2 - 1.8) / 0.15)
    = 4 + (0.2 / 0.15)
    = 4 + 1.33
    = 5.33
</code></pre></span></div><br />
<br />
So we could run at just over 5 MHz at 2V.<br />
<br />
<div class="heading">Summary of volts per MHz</div><br />
<br />
To summarize the voltages required for each MHz of frequency, from the above formulae:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
<b>MHz  Volts</b>
 4    1.80
 5    1.95
 6    2.10
 7    2.25
 8    2.40
 9    2.55
10    2.70
11    2.88
12    3.06
13    3.24
14    3.42
15    3.60
16    3.78
17    3.96
18    4.14
19    4.32
20    4.50
</code></pre></span></div><br />
<br />
<br />
<div class="heading">Battery self-discharge rates</div><br />
<br />
A discussion of power saving techniques isn&#039;t really complete without considering the self-discharge rates of various types of batteries. There isn&#039;t much point in saving a micro-amp here and there if the battery is self-discharging at the rate of 500 &micro;A!<br />
<br />
Based on various pieces of research, I have put together a <i>guide</i> for the rate at which various types of batteries self-discharge, and therefore what the &quot;equivalent&quot; current is:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
Type        Capacity mAH  Discharge %/month   Self discharge (&micro;A)

CR1212            18              1                  0.250
CR1620            68              1                  0.950
CR2032           210              1                  3
NiCD AAA         350             20                 98
NiMH AAA         900             30                375
NiCd AA         1000             20                270
Alkaline AAA    1250              2                 35
NiMH AA         2400             30               1000
Alkaline AA     2890              2                 80
Li-Ion          4400             10                600
</code></pre></span></div><br />
<br />
<i>All figures are approximate and intended as a guide only. Different batteries have different capacities, and self-discharge rates are not flat (that is, they tend to self-discharge faster at the start). Also self-discharge rates are influenced by temperature.</i><br />
<br />
You can see that NiMH batteries in particular discharge very quickly, so even just leaving one in a box is equivalent to connecting it up to circuit which draws 1 mA!<br />
<br />
On the other hand, lithium (button) batteries discharge quite slowly (at 250 nA), so saving a microamp in your application is worthwhile.<br />
<br />
<div class="heading">Formula for self-discharge rates</div><br />
<br />
Batteries are often quoted with a self-discharge rate of x% per month. <br />
<br />
So, for (say) a battery with 1250 mAH of capacity, and a 2% self-discharge rate, per month, it follows that at the end of one month, we will have lost 2 / 100 * 1250 mAH of capacity. That is, 25 mAH less are available. It further follows that we would have lost (x / 100) / (24 * 30) capacity in <b>one hour</b> (24 hours in a day, 30 days in a month, average). Thus we have lost 25 / (24 * 30) = 0.03472 mAH capacity in one hour.<br />
<br />
To lose 0.03472 mAH capacity over one hour we would have to have had a current consumption of 0.03472 mA <b>for that hour</b>. Thus the self-discharge rate is effectively the same as using 34.72 &micro;A continuously.<br />
<br />
So:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
equivalent_current_mA = (percent_monthly_discharge_rate / 100) * capacity_maH / (24 * 30) 
</code></pre></span></div><br />
<br />
<div class="heading">Detecting low voltage</div><br />
<br />
All this power saving is well and good, but eventually our battery will run down, and we need to detect that so we can flash a &quot;low battery&quot; LED, sound a beeper, or something.<br />
<br />
One reasonably useful way of doing that is to let the processor work out its own Vcc (power) voltage. To do this, we can use the function getBandgap, which finds the voltage of the Vcc line by using the ADC converter to compare the Vcc line to the internal 1.1 reference voltage.<br />
<br />
An example sketch which demonstrates the technique:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
void setup(void)
  {
  Serial.begin(115200);
  }
    
void loop(void)
  {
  Serial.println (getBandgap ());
  delay(1000);
  }

<b>const long InternalReferenceVoltage = 1062;</b>  // Adjust this value to your board&#039;s specific internal BG voltage
 
// Code courtesy of &quot;Coding Badly&quot; and &quot;Retrolefty&quot; from the Arduino forum
// results are Vcc * 100
// So for example, 5V would be 500.
int getBandgap () 
  {
  // REFS0 : Selects AVcc external reference
  // MUX3 MUX2 MUX1 : Selects 1.1V (VBG)  
   ADMUX = bit (REFS0) | bit (MUX3) | bit (MUX2) | bit (MUX1);
   ADCSRA |= bit( ADSC );  // start conversion
   while (ADCSRA &amp; bit (ADSC))
     { }  // wait for conversion to complete
   int results = (((InternalReferenceVoltage * 1024) / ADC) + 5) / 10; 
   return results;
  } // end of getBandgap
</code></pre></span></div><br />
<br />
If you try this out you should see some numbers scroll by, close to 500 (if you are using 5V power source). There will be an error factor of a few percent, but it should be close enough that you can use it to predict when the battery is getting low. <br />
<br />
To get a more accurate result, you need to find the internal reference voltage. To do that, run this sketch:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
// Find internal 1.1 reference voltage on AREF pin
void setup ()
{
  ADMUX = bit (REFS0) | bit (REFS1);
}
void loop () { }
</code></pre></span></div><br />
<br />
Or, more simply:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
// Find internal 1.1 reference voltage on AREF pin
void setup ()
{
  analogReference (INTERNAL);
  analogRead (A0);  // force voltage reference to be turned on
}
void loop () { }
</code></pre></span></div><br />
<br />
Then use a voltmeter to measure the voltage on the AREF pin of the processor. Multiply that by 1000 and use it as the InternalReferenceVoltage variable above. For example, I got 1.062 volts when I tried it.<br />
<br />
If you are deploying your sketch on multiple processors you might store the internal reference voltage in EEPROM, for each processor, so the sketch can consult that to find the exact figure to use when calculating the voltage.<br />
<br />
<br />
<div class="heading">Warning about low voltage</div><br />
<br />
The next issue is, how do we tell our users that the battery needs replacing? Once we know the battery voltage is low, we need to somehow communicate that fact. Of course, if we have some sort of communication system (eg. radio, Ethernet) we can simply transmit a &quot;low battery&quot; message.<br />
<br />
Failing that, a warning LED might do the trick. The problem is that turning on an LED is likely to drain the battery even faster, so we need to do it with caution.<br />
<br />
Experiments with &quot;high-power&quot; (8000 mcd) LEDs show that, even pulsed at only 1 mS per second, they are quite noticeable, at least if you are looking straight at them.<br />
<br />
So a function like this could make a flashing &quot;warning&quot; LED:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
void lowBatteryWarning () 
  {
  digitalWrite (LED, HIGH);  
  delay (1);       // mS        
  digitalWrite (LED, LOW);    
  delay (999);             
  }</code></pre></span></div><br />
<br />
Since this has a duty cycle of 1/1000 of a second, then the 20 mA current drawn is divided by 1000, so on average it is drawing 20 &micro;A. In my test I had a 100 ohm resistor in series with the LED. In fact even an &quot;ordinary&quot; red LED, with the 100 ohm resistor, and the same blink rate, was quite visible.<br />
<br />
<div class="heading">Battery life calculator</div><br />
<br />
You may find this <a href="http://oregonembedded.com/batterycalc.htm">battery life calculator</a> useful.</td></tr><tr><td><hr >
<font size=1 color="#808080">- Nick Gammon<br />
<br />
www.gammon.com.au, www.mushclient.com</font></td></tr><tr align=right><td><font size=1><a href="#top"><img src="/images/gototop.gif" alt="[Go to top]" width=15 height=15 border=0>&nbsp;top</a> </font></td></tr></table>
</div></td>
  </tr>
</table>
<hr>
<a name="reply3"></a><a name="70219"></a>
<table border=0 cellpadding=5 width="100%">
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Posted by</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><b>Nick Gammon</b></a>
<font size=1>&nbsp;&nbsp;Australia</font>&nbsp;&nbsp;<font size=1>(21,244 posts)</font>&nbsp;&nbsp;<font size=1><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><img src="/images/bio.gif" border=0 width=15 height=15 alt="[Biography]">&nbsp;bio</a>
</font>&nbsp;&nbsp;<font size=1><i>Forum Administrator</i></font></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Date</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/?id=11497&reply=3#reply3">Reply #3</a> on Sat 28 Jan 2012 02:08 AM (UTC)<p><font size=1>Amended on Sun 05 Apr 2015 11:37 PM (UTC) by <a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank">Nick Gammon</a>
</font></p></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Message</b></td>
    <td bgcolor="#FAF0E6" align=left><div class=postbody><table width="100%"><tr><td><div class="heading">Powering off external devices</div><br />
<br />
Another thing you can do to save power is &quot;power off&quot; external chips (such as clock chips) when they aren&#039;t needed.<br />
<br />
As an example, say you need to know the time (because you are logging temperatures inside your shed, for instance). But to leave the Real Time Clock (RTC) chip running all the time might use a few hundred microamps, if not more.<br />
<br />
To save that current, power the clock from a spare digital pin (eg. D8) and just set the pin to output, and high (+5V) when required. Example circuit:<br />
<br />
<img src="/images/Atmega_with_RTC_clock_11497.png"><br />
<br />
The 220 ohm resistor is to stop too much current flowing through the output pin to charge the 0.1 uF decoupling capacitor. Since we don&#039;t want much more than 20 mA drawn from the pin, the value R = E/I, namely 5 / 0.020, giving 250 ohms. In fact 220 ohms (the nearest standard resistor value) would allow a maximum of 22.7 mA, which is acceptable for an output pin.<br />
<br />
An example sketch:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
#include &lt;Wire.h&gt;
#include &quot;RTClib.h&quot;

#include &lt;avr/sleep.h&gt;
#include &lt;avr/wdt.h&gt;

RTC_DS1307 RTC;

#define CLOCK_POWER 8

// watchdog interrupt
ISR (WDT_vect) 
{
  wdt_disable();  // disable watchdog
}

void myWatchdogEnable() 
{
  // clear various &quot;reset&quot; flags
  MCUSR = 0;     
  // allow changes, disable reset
  WDTCSR = bit (WDCE) | bit (WDE);
  // set interrupt mode and an interval 
  WDTCSR = bit (WDIE) | bit (WDP3) | bit (WDP0);    // set WDIE, and 8 seconds delay
  wdt_reset();  // pat the dog

  // disable ADC
  ADCSRA = 0;  

  // ready to sleep
  set_sleep_mode (SLEEP_MODE_PWR_DOWN);  
  sleep_enable();

  // turn off brown-out enable in software
  MCUCR = bit (BODS) | bit (BODSE);
  MCUCR = bit (BODS); 
  sleep_cpu ();  

  // cancel sleep as a precaution
  sleep_disable();
} 

void setup()
{
  RTC.begin();  // activate clock (doesn&#039;t do much)
}  // end of setup

void loop()
{

  // power up clock chip
  digitalWrite (CLOCK_POWER, HIGH);
  pinMode (CLOCK_POWER, OUTPUT);

  // activate I2C
  Wire.begin();

  // find the time  
  DateTime now = RTC.now();

  // time now available in now.hour(), now.minute() etc.

  // finished with clock
  pinMode (CLOCK_POWER, INPUT);  
  digitalWrite (CLOCK_POWER, LOW); 

  // turn off I2C
  TWCR &amp;= ~(bit(TWEN) | bit(TWIE) | bit(TWEA));

  // turn off I2C pull-ups
  digitalWrite (A4, LOW);
  digitalWrite (A5, LOW);


  // -------- do something here if required by the time of day



  // sleep for a total of 64 seconds (8 x 8)
  for (int i = 0; i &lt; 8; i++)
    myWatchdogEnable (); 

}  // end of loop
</code></pre></span></div><br />
<br />
A couple of tricky parts:<br />
<br />
<br /><ul>
<li>We make the pin high before switching it to output, to save forcing the capacitor low<br />
<li>The RTC chip is actually &quot;alive&quot; all the time from its battery backup, it just is not allowed to use I2C without external power. So we don&#039;t have to wait long before we use it.<br />
<li>Once finished we set the pin to input first, and then to low, again to save draining the capacitor<br />
<li>We turn off the I2C hardware<br />
<li>We turn off the I2C pull-ups to save power<br />
</ul><br />
<br />
Then a loop of 8 lots of 8-second watchdog timer sleeps gives us about a minute&#039;s delay. Of course we could make that longer. Then we can check the time from the clock to see if it is time to do anything.<br />
<br />
The measured current drain during that test was 6.4 &micro;A almost all of the time, with a current drain of 22.8 mA for 1 mS (while the clock was being read).<br />
<br />
This technique requires that the device you are powering from a digital pin does not draw more than the pin can supply (ie. 20 mA). If it required more you would need to turn on a MOSFET transistor which in turn could power on the device.<br />
<br />
<b>[EDIT]</b> As pointed out on the Arduino forum, the voltage drop over the 220 ohm resistor is going to make this system not work for devices that draw much more than a milliamp or so. In the case of the DS1307, it draws around 1.5 mA when active, so over 220 ohms there would be a voltage drop from 5V of 0.33V, bringing it close to its lower operating voltage.<br />
<br />
For devices that draw more current it is probably better to drive a suitable MOSFET to switch the power on and off ...<br />
<br />
<img src="/images/Arduino/MOSFET_high_side_driver_5V.png"></td></tr><tr><td><hr >
<font size=1 color="#808080">- Nick Gammon<br />
<br />
www.gammon.com.au, www.mushclient.com</font></td></tr><tr align=right><td><font size=1><a href="#top"><img src="/images/gototop.gif" alt="[Go to top]" width=15 height=15 border=0>&nbsp;top</a> </font></td></tr></table>
</div></td>
  </tr>
</table>
<hr>
<a name="reply4"></a><a name="72100"></a>
<table border=0 cellpadding=5 width="100%">
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Posted by</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><b>Nick Gammon</b></a>
<font size=1>&nbsp;&nbsp;Australia</font>&nbsp;&nbsp;<font size=1>(21,244 posts)</font>&nbsp;&nbsp;<font size=1><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><img src="/images/bio.gif" border=0 width=15 height=15 alt="[Biography]">&nbsp;bio</a>
</font>&nbsp;&nbsp;<font size=1><i>Forum Administrator</i></font></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Date</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/?id=11497&reply=4#reply4">Reply #4</a> on Sat 17 Nov 2012 10:59 PM (UTC)<p><font size=1>Amended on Mon 24 Oct 2016 09:19 PM (UTC) by <a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank">Nick Gammon</a>
</font></p></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Message</b></td>
    <td bgcolor="#FAF0E6" align=left><div class=postbody><table width="100%"><tr><td><div class="heading">Detecting key presses on a keypad whilst asleep</div><br />
<br />
The sketch below illustrates how you can connect up a 16-key keypad to your processor, and then sleep until a key is pressed.<br />
<br />
This uses the Keypad2 library (not sure where I got that) but the concept should be similar for all similar libraries.<br />
<br />
The general idea is that, before sleeping, the sketch sets all the rows to HIGH (pull-up) and all columns to LOW (output). Now, if no button is pressed all the rows will be high (because of the pull-up). Then if a button is pressed the row will go LOW, and cause a pin change. The pin-change interrupt fires, waking the processor.<br />
<br />
The sketch then reconfigures the rows and columns back to how they were in the keypad library, and calls keypad.getKey () to find which key was pressed.<br />
<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
// Wake from deep sleep with a keypress demonstration

// Author: Nick Gammon
// Date: 18th November 2012

#include &lt;Keypad2.h&gt;
#include &lt;avr/sleep.h&gt;
#include &lt;avr/power.h&gt;

const byte ROWS = 4;
const byte COLS = 4; 

char keys[ROWS][COLS] = 
  {
    {&#039;1&#039;, &#039;2&#039;, &#039;3&#039;, &#039;A&#039;},
    {&#039;4&#039;, &#039;5&#039;, &#039;6&#039;, &#039;B&#039;},
    {&#039;7&#039;, &#039;8&#039;, &#039;9&#039;, &#039;C&#039;},
    {&#039;*&#039;, &#039;0&#039;, &#039;#&#039;, &#039;D&#039;},
  };

byte rowPins[ROWS] = {6, 7, 8, 9}; //connect to the row pinouts of the keypad
byte colPins[COLS] = {2, 3, 4, 5}; //connect to the column pinouts of the keypad
  
// number of items in an array
#define NUMITEMS(arg) ((unsigned int) (sizeof (arg) / sizeof (arg [0])))

const byte ledPin = 13;

  // Create the Keypad
Keypad kpd = Keypad( makeKeymap(keys), rowPins, colPins, ROWS, COLS );

/*

Pin change interrupts.

Pin                  Mask / Flag / Enable

D0	  PCINT16 (PCMSK2 / PCIF2 / PCIE2)
D1	  PCINT17 (PCMSK2 / PCIF2 / PCIE2)
D2	  PCINT18 (PCMSK2 / PCIF2 / PCIE2)
D3	  PCINT19 (PCMSK2 / PCIF2 / PCIE2)
D4	  PCINT20 (PCMSK2 / PCIF2 / PCIE2)
D5	  PCINT21 (PCMSK2 / PCIF2 / PCIE2)
D6	  PCINT22 (PCMSK2 / PCIF2 / PCIE2)
D7	  PCINT23 (PCMSK2 / PCIF2 / PCIE2)
D8	  PCINT0 (PCMSK0 / PCIF0 / PCIE0)
D9	  PCINT1 (PCMSK0 / PCIF0 / PCIE0)
D10	  PCINT2 (PCMSK0 / PCIF0 / PCIE0)
D11	  PCINT3 (PCMSK0 / PCIF0 / PCIE0)
D12	  PCINT4 (PCMSK0 / PCIF0 / PCIE0)
D13	  PCINT5 (PCMSK0 / PCIF0 / PCIE0)
A0	  PCINT8 (PCMSK1 / PCIF1 / PCIE1)
A1	  PCINT9 (PCMSK1 / PCIF1 / PCIE1)
A2	  PCINT10 (PCMSK1 / PCIF1 / PCIE1)
A3	  PCINT11 (PCMSK1 / PCIF1 / PCIE1)
A4	  PCINT12 (PCMSK1 / PCIF1 / PCIE1)
A5	  PCINT13 (PCMSK1 / PCIF1 / PCIE1)

*/

// turn off interrupts until we are ready
ISR (PCINT0_vect)
  {
  PCICR = 0;  // cancel pin change interrupts
  } // end of ISR (PCINT0_vect)

ISR (PCINT1_vect)
  {
  PCICR = 0;  // cancel pin change interrupts
  } // end of ISR (PCINT1_vect)

ISR (PCINT2_vect)
  {
  PCICR = 0;  // cancel pin change interrupts
  } // end of ISR (PCINT2_vect)

void setup ()
  {
  pinMode (ledPin, OUTPUT);
  
  // pin change interrupt masks (see above list)
  PCMSK2 |= bit (PCINT22);   // pin 6
  PCMSK2 |= bit (PCINT23);   // pin 7
  PCMSK0 |= bit (PCINT0);    // pin 8
  PCMSK0 |= bit (PCINT1);    // pin 9

  }  // end of setup

// set pins as keypad library expects them
// or call: kpd.initializePins ();
//    however in the library I have that is a private method

void reconfigurePins ()
  {
  byte i;
  
  // go back to all pins as per the keypad library
  
  for (i = 0; i &lt; NUMITEMS (colPins); i++)
    {
    pinMode (colPins [i], OUTPUT);
    digitalWrite (colPins [i], HIGH); 
    }  // end of for each column 

  for (i = 0; i &lt; NUMITEMS (rowPins); i++)
    {
    pinMode (rowPins [i], INPUT_PULLUP);
    }   // end of for each row

  }  // end of reconfigurePins

void goToSleep ()
  {
  byte i;
   
  // set up to detect a keypress
  for (i = 0; i &lt; NUMITEMS (colPins); i++)
    {
    pinMode (colPins [i], OUTPUT);
    digitalWrite (colPins [i], LOW);   // columns low
    }  // end of for each column

  for (i = 0; i &lt; NUMITEMS (rowPins); i++)
    {
    pinMode (rowPins [i], INPUT_PULLUP);
    }  // end of for each row
    
   // now check no pins pressed (otherwise we wake on a key release)
   for (i = 0; i &lt; NUMITEMS (rowPins); i++)
    {
    if (digitalRead (rowPins [i]) == LOW)
       {
       reconfigurePins ();
       return; 
       } // end of a pin pressed
    }  // end of for each row
  
  // overcome any debounce delays built into the keypad library
  delay (50);
  
  // at this point, pressing a key should connect the high in the row to the 
  // to the low in the column and trigger a pin change
  
  set_sleep_mode (SLEEP_MODE_PWR_DOWN);  
  sleep_enable();

  byte old_ADCSRA = ADCSRA;
  // disable ADC to save power
  ADCSRA = 0;  

  power_all_disable ();  // turn off various modules
   
  PCIFR  |= bit (PCIF0) | bit (PCIF1) | bit (PCIF2);   // clear any outstanding interrupts
  PCICR  |= bit (PCIE0) | bit (PCIE1) | bit (PCIE2);   // enable pin change interrupts
   
  // turn off brown-out enable in software
  MCUCR = bit (BODS) | bit (BODSE);
  MCUCR = bit (BODS); 
  sleep_cpu ();  
 
  // cancel sleep as a precaution
  sleep_disable();
  power_all_enable ();   // enable modules again
  ADCSRA = old_ADCSRA;   // re-enable ADC conversion
  
  // put keypad pins back how they are expected to be
  reconfigurePins ();
    
  }  // end of goToSleep
  
void loop () 
  {
   
   byte key =  kpd.getKey();
   if (!key)
     {
     // no key pressed? go to sleep
     goToSleep ();
     return;
     }

  // confirmation we woke - flash LED number of times
  // for the appropriate pin (eg. pin 1: one time) 
  for (byte i = 0; i &lt; (key - &#039;0&#039;); i++)
    {
    digitalWrite (ledPin, HIGH);
    delay (500); 
    digitalWrite (ledPin, LOW);
    delay (500); 
    } // end of for loop
    
  } // end of loop

</code></pre></span></div><br />
<br />
<b>Power consumption</b><br />
<br />
Tested on a &quot;bare bones&quot; board, when asleep the sketch used only 100 nA (0.1 &micro;A) of power, even on a 5V supply, and a 16 MHz clock rate.<br />
<br />
The sketch above just flashes LED 13 to prove it woke up, but in practice you would replace that code (at the end) to do something useful.<br />
<br />
<b>Applications</b><br />
<br />
This general idea would be useful in situation where you want a device to use very little power until activated. For example:<br />
<br />
<br /><ul>
<li>Calculator<br />
<li>Safe combination lock<br />
<li>Front door lock<br />
<li>TV remote<br />
<li>Logging device (eg. for orienteering)<br />
</ul><br />
<br />
<div class="heading">Wiring for Uno</div><br />
<br />
<img src="/images//Arduino/16_key_keypad.JPG"><br />
<br />
Numbers shown are the &quot;digital&quot; pin numbers for an Arduino Uno. For the raw Atmega328P chip the pins would be (from left to right for the PDIP version): 4, 5, 6, 11, 12, 13, 14, 15.<br />
<br />
Possibly other keypads would have different wiring configurations. You can test by using a multimeter in &quot;continuity&quot; mode and testing for which keys close which pins. For example, in my case measuring between the first column (labelled 2 on the photo above) and the first row (labelled 6 on the photo) causes those two to be connected when I press the &quot;1&quot; button (because that is in row 1, column 1).<br />
<br />
<div class="heading">Keypad2 library</div><br />
<br />
A copy of the library used in the above sketch can be downloaded here: <a href="http://www.gammon.com.au/Arduino/Keypad2.zip">http://www.gammon.com.au/Arduino/Keypad2.zip</a></td></tr><tr><td><hr >
<font size=1 color="#808080">- Nick Gammon<br />
<br />
www.gammon.com.au, www.mushclient.com</font></td></tr><tr align=right><td><font size=1><a href="#top"><img src="/images/gototop.gif" alt="[Go to top]" width=15 height=15 border=0>&nbsp;top</a> </font></td></tr></table>
</div></td>
  </tr>
</table>
<hr>
<a name="reply5"></a><a name="72902"></a>
<table border=0 cellpadding=5 width="100%">
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Posted by</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><b>Nick Gammon</b></a>
<font size=1>&nbsp;&nbsp;Australia</font>&nbsp;&nbsp;<font size=1>(21,244 posts)</font>&nbsp;&nbsp;<font size=1><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><img src="/images/bio.gif" border=0 width=15 height=15 alt="[Biography]">&nbsp;bio</a>
</font>&nbsp;&nbsp;<font size=1><i>Forum Administrator</i></font></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Date</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/?id=11497&reply=5#reply5">Reply #5</a> on Sun 17 Mar 2013 05:15 AM (UTC)<p><font size=1>Amended on Sat 23 Aug 2014 05:30 AM (UTC) by <a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank">Nick Gammon</a>
</font></p></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Message</b></td>
    <td bgcolor="#FAF0E6" align=left><div class=postbody><table width="100%"><tr><td><div class="heading">Low-power temperature monitor</div><br />
<br />
Following on from a query on the Arduino forum, I devised this temperature monitor sketch. It is intended to flash an LED if the detected ambient temperature falls outside a specified range (eg. 20 degrees to 30 degrees). Instead of flashing an LED you could sound a buzzer or similar.<br />
<br />
<div class="heading">Schematic</div><br />
<br />
<img src="/images/Arduino/Temperature_monitor_11497.png"><br />
<br />
<div class="heading">Code</div><br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
// Temperature monitoring system

// Author: Nick Gammon
// Date:   16 March 2013
// Version: 1.1 - uses sleep during ADC conversion
// Version: 1.2 - has shorter LED flash to save power
// Version: 1.3 - has &quot;cold&quot; and &quot;hot&quot; LEDs (could be the same pin)
// Version: 1.4 - has a &quot;heartbeat&quot; LED

// Thermistor calculation adapted from: http://learn.adafruit.com/thermistor/using-a-thermistor

#include &lt;avr/sleep.h&gt;
#include &lt;avr/wdt.h&gt;

// Flash LED if temperature outside this range:
const float lowTemp = 20.0;      // degrees C
const float highTemp = 24.0;     // degrees C

// the bigger this is, the less power we consume
const int timeBetweenReadings = 30;  // seconds

const byte hotLED = 2;    // which LED to flash if too hot
const byte coldLED = 9;   // which LED to flash if too cold
const byte heartbeatLED = 8;  // flash briefly to indicate we are alive

#define DEBUGGING false

// Wiring:   Gnd &lt;----&gt; 5K Thermistor &lt;----&gt; |   &lt;-----&gt;&gt;   4.7K resistor  &lt;-----&gt; AREF
//                                           |
//                                           v
//                                           A0

// which analog pin to connect
const byte THERMISTORPIN = 0;

// temp. for nominal resistance (almost always 25 C) 
const int TEMPERATURENOMINAL = 25;

// resistance at TEMPERATURENOMINAL (above)
const int THERMISTORNOMINAL = 5000;

// how many samples to take and average, more takes longer but is more &#039;smooth&#039;
const int NUMSAMPLES = 5;

// The beta coefficient of the thermistor (usually 3000-4000) 
const int BCOEFFICIENT = 3960;

// the value of the &#039;other&#039; resistor (measure to make sure)
const int SERIESRESISTOR = 4640;

// how many Kelvin 0 degrees Celsius is
const float KELVIN = 273.15;

// what was our last reading
float lastReading;  // degrees

// how many seconds till we take another reading (updated as we enter sleep mode)
float nextReadingTime = 0;  // seconds

// watchdog intervals
// sleep bit patterns for WDTCSR
enum 
{
  WDT_16_MS  =  0b000000,
  WDT_32_MS  =  0b000001,
  WDT_64_MS  =  0b000010,
  WDT_128_MS =  0b000011,
  WDT_256_MS =  0b000100,
  WDT_512_MS =  0b000101,
  WDT_1_SEC  =  0b000110,
  WDT_2_SEC  =  0b000111,
  WDT_4_SEC  =  0b100000,
  WDT_8_SEC  =  0b100001,
 };  // end of WDT intervals enum

void setup (void) 
  { 
    
#if DEBUGGING
  Serial.begin(115200); 
#endif // DEBUGGING

  pinMode (coldLED, OUTPUT);
  pinMode (hotLED, OUTPUT);
  pinMode (heartbeatLED, OUTPUT);
  
  // flash LEDs 5 times to confirm battery attached properly
  for (byte i = 0; i &lt; 5; i++)
    {
    digitalWrite (coldLED, HIGH);
    delay (100);      
    digitalWrite (coldLED, LOW);
    delay (100);      
    digitalWrite (hotLED, HIGH);
    delay (100);      
    digitalWrite (hotLED, LOW);
    delay (100);      
    }
   
  // stop timer 0 to avoid unwanted interrupts
  TCCR0A = 0;
  TCCR0B = 0;
 
  // set the analog reference (high two bits of ADMUX) and select the
  // channel (low 4 bits).  this also sets ADLAR (left-adjust result)
  // to 0 (the default).
  ADMUX = bit (REFS0) | bit (REFS1) | (THERMISTORPIN &amp; 0x07);  // Internal 1.1V reference
  
  lastReading = getTemperature ();
  }  // end of setup
  
// watchdog interrupt
ISR (WDT_vect) 
  {
  wdt_disable();  // disable watchdog
  }

void myWatchdogEnable (const byte interval) 
  {
  // clear various &quot;reset&quot; flags
  MCUSR = 0;     
  // allow changes, disable reset
  WDTCSR = bit (WDCE) | bit (WDE);
  // set interrupt mode and an interval 
  WDTCSR = bit (WDIE) | interval;    // set WDIE, and requested delay
  wdt_reset();  // pat the dog

  // disable ADC
  byte old_ADCSRA = ADCSRA;
  ADCSRA = 0;  
  
  // turn off various modules
  byte old_PRR = PRR;
  PRR = 0xFF; 

  // timed sequence coming up
  noInterrupts ();
  
  // ready to sleep
  set_sleep_mode (SLEEP_MODE_PWR_DOWN);  
  sleep_enable();

  // turn off brown-out enable in software
  MCUCR = bit (BODS) | bit (BODSE);
  MCUCR = bit (BODS); 
  interrupts ();
  sleep_cpu ();  

  // cancel sleep as a precaution
  sleep_disable();
  PRR = old_PRR;
  ADCSRA = old_ADCSRA;
  
  } // end of myWatchdogEnable

// when ADC completed, take an interrupt 
EMPTY_INTERRUPT (ADC_vect);
  
float getTemperature ()
  {
  byte i;
  float average = 0.0;
  
  // take N samples in a rowy 
  for (i = 0; i &lt; NUMSAMPLES; i++) 
    {
    // ensure not interrupted before we sleep
    noInterrupts ();
    
    // start the conversion
    ADCSRA |= bit (ADSC) | bit (ADIE);
    set_sleep_mode (SLEEP_MODE_ADC);    // sleep during sample
    interrupts ();
    sleep_mode (); 

    // reading should be done, but better make sure
    // maybe the timer interrupt fired 

    // ADSC is cleared when the conversion finishes
    while (bit_is_set (ADCSRA, ADSC))
      { }
    
    // get ADC data
    byte low, high;
    
    // we have to read ADCL first; doing so locks both ADCL
    // and ADCH until ADCH is read.  reading ADCL second would
    // cause the results of each conversion to be discarded,
    // as ADCL and ADCH would be locked when it completed.
    low = ADCL;
    high = ADCH;
  
    int adcReading = (high &lt;&lt; 8) | low;
  
    average += adcReading;
    }  // end of for each of NUMSAMPLES
    
  average /= NUMSAMPLES; 

  // convert the value to resistance 
  average = 1023 / average - 1; 
  average = SERIESRESISTOR / average; 

  float steinhart = average / THERMISTORNOMINAL;
  steinhart = log (steinhart); 
  steinhart /= BCOEFFICIENT; 
  steinhart += 1.0 / (TEMPERATURENOMINAL + KELVIN); 
  steinhart = 1.0 / steinhart; 
  steinhart -= KELVIN;   // back to celsius
  return steinhart;
  }  // end of getTemperature
  
void takeReading ()
  {
  // quick flash of hearbeat LED
  digitalWrite (heartbeatLED, HIGH);
  delayMicroseconds (1000);
  digitalWrite (heartbeatLED, LOW);
  
  lastReading = getTemperature ();
#if DEBUGGING
  Serial.print (&quot;Temperature = &quot;); 
  Serial.print (lastReading);
  Serial.println (&quot; *C&quot;);
#endif // DEBUGGING

  if ((lastReading &lt; lowTemp) || (lastReading &gt; highTemp))
    nextReadingTime = 5;    // if out of range, read again in 5 seconds
  else
    nextReadingTime = timeBetweenReadings;    // when to take another reading
  }  // end of takeReading
  
boolean ledOn;

void loop (void) 
  { 
  if (nextReadingTime &lt;= 0)
    takeReading ();
    
  byte waitTime;
  
  if (lastReading &lt; lowTemp)
    {
    if (ledOn)
      {
      // off for one second (slow flash rate)
      waitTime = WDT_1_SEC;
      nextReadingTime -= 1.000;
      digitalWrite (coldLED, LOW);
      }
    else
      {
      // brief flash to save power (16 mS)
      waitTime = WDT_16_MS;
      nextReadingTime -= 0.016;
      digitalWrite (coldLED, HIGH);
      }  
    ledOn = !ledOn;
    
#if DEBUGGING
    Serial.println (&quot;Too low!&quot;);
#endif // DEBUGGING
    }
  else if (lastReading &gt; highTemp)
    {
    if (ledOn)
      {
      // off for half a second (fast flash rate)
      waitTime = WDT_512_MS;
      nextReadingTime -= 0.512;
      digitalWrite (hotLED, LOW);
      }
    else
      {
      // brief flash to save power (16 mS)
      waitTime = WDT_16_MS;
      nextReadingTime -= 0.016;
      digitalWrite (hotLED, HIGH);
      }  
    ledOn = !ledOn;

#if DEBUGGING
    Serial.println (&quot;Too HIGH!&quot;);
#endif // DEBUGGING
    }
  else
    {
    // temperature OK - sleep for 8 seconds
    waitTime = WDT_8_SEC;
    nextReadingTime -= 8; 
    digitalWrite (coldLED, LOW);
    digitalWrite (hotLED, LOW);
    ledOn = false;
    }
    
#if DEBUGGING
  // force serial data out, wait for UART to empty
  Serial.flush ();
#endif // DEBUGGING

  myWatchdogEnable (waitTime);
  }  // end of loop
</code></pre></span></div><br />
<br />
This was written for the Atmega328P but because it only uses a few pins could probably work on the ATtiny85 or similar.<br />
<br />
The processor was set up to run from the internal 8 MHz oscillator, and was powered from about 3V (eg. from two to three AA batteries).<br />
<br />
<div class="heading">Power budgeting</div><br />
<br />
I measured around 4.2 &micro;A whilst asleep (most of the time) which would be about the amount that the watchdog timer takes while active. The watchdog timer was used to wake the sketch up every 8 seconds (the maximum you can run the watchdog timer) and then go back to sleep until 32 seconds had elapsed. In the event that the temperature was out of range then a smaller watchdog interval would be chosen, to make the LED blink slowly (too cold) or quickly (too hot).<br />
<br />
Of course, the LED, while blinking, takes a few milliamps of current, so that would increase the drain on the battery.<br />
<br />
Assuming it does not blink often, the other overheads are:<br />
<br />
<br /><ol>
<li>Waking up and going back to sleep. This takes around 150 uS and consumes about 2 mA. This normally happens every 8 seconds.<br />
<br />
<li>Taking another temperature reading. This takes around 2.5 mS and consumes about 2.7 mA. This normally happens ever 32 seconds.<br />
</ol><br />
<br />
<br />
Power consumption during the ADC reading:<br />
<br />
<img src="/images/Arduino/Arduino_forum_154217.png"><br />
<br />
During the ADC reading the processor is put into &quot;ADC&quot; sleep mode, which reduces power while the reading is taken, and reduces noise in the reading. You can see the 5 blips in the screenshot as the power is lowered during the readings. The red line is the difference between channel 1 and channel 2, which were clipped to each side of a 10K resistor, in order to measure the current passing through it.<br />
<br />
The extra current needed to take readings, being averaged out over 32 seconds, and only taking 2.5/1000 milliseconds, would effectively average to:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
(2.7 * (2.5 / 1000)) / 32 = 0.00021
</code></pre></span></div><br />
<br />
In other words, only 0.21 &micro;A additional, added to the constant drain of 4.2 &micro;A. Thus you could roughly predict that the circuit would use 4.4 &micro;A, which is somewhat less than the self-discharge rate of most batteries.<br />
<br />
<div class="heading">Debugging</div><br />
<br />
The debugging displays (disabled in the code as posted) could be used to confirm that you are getting the right readings from your thermistor. You might do that on a Uno before transferring the code to a smaller board.<br />
<br />
<div class="tip"><br />
<b>Tip:</b><br />
You can test it by putting your finger on the thermistor to heat it up. You have to wait up to 30 seconds for the next temperature sample.<br />
<br />
You can also test it by putting it in the refrigerator to cool it down.<br />
</div><br />
<br />
<div class="heading">Calculation constants</div><br />
<br />
I used a NJ28MA0502G 5K thermistor, and the relevant figures are in the datasheet:<br />
<br />
<img src="/images/Arduino/Thermistor_11497.png"><br />
<br />
From the code:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
// temp. for nominal resistance (almost always 25 C) 
const int TEMPERATURENOMINAL = <b>25</b>;      // &lt;------ see chart above

// resistance at TEMPERATURENOMINAL (above)
const int THERMISTORNOMINAL = <b>5000</b>;     // &lt;------ see chart above

// The beta coefficient of the thermistor (usually 3000-4000) 
const int BCOEFFICIENT = <b>3960</b>;          // &lt;------ see chart above

// the value of the &#039;other&#039; resistor (measure to make sure)
const int SERIESRESISTOR = <b>4640</b>;        // &lt;------ actual value measured on my &quot;4.7K&quot; resistor
</code></pre></span></div><br />
<br />
<br />
<div class="heading">Prototype board</div><br />
<br />
<img src="/images/Arduino/Thermistor_board_11497.jpg"><br />
<br />
The blue capacitors are 0.1 uF decoupling capacitors.<br />
<br />
<div class="heading">Improvements</div><br />
<br />
1. Sketch modified 18 March 2013 to flash the LED for briefer intervals (16 mS each) to save power when doing the &quot;warning flash&quot;. This was instead of half-a-second on, and half-a-second off.<br />
<br />
2. Also added a quick set of 5 flashes when first powered on. This is to confirm that you have the battery connected properly, that the battery isn&#039;t flat, or there is a loose wire, or something.<br />
<br />
3. Modified code to support &quot;hot&quot; and &quot;cold&quot; LEDs. That is, you could have a red LED to show the temperature is too hot and a blue one to show it is too cold. If you only want one LED, just make both pin numbers the same.<br />
<br />
4. Sketch modified 19 March 2013 to add a &quot;heartbeat&quot; LED. The idea is that, without it, you couldn&#039;t be sure if the monitor was reporting &quot;temperature OK&quot; or had simply died due to a flat battery, bad connection, or something. (This was my son&#039;s suggestion).  The heartbeat LED flashes briefly (2 mS) every time a reading is taken. This is enough to be visible, but the average current drain (for a 10 mA LED) would be:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
 10 (mA) * 2 mS (secs) / 32 (every 32 secs)  = 0.625 &micro;A
</code></pre></span></div><br />
<br />
So for the sake of an average extra amount of under a micro-amp, you can have confidence it is working, if you stare at it for about 30 seconds.<br />
<br />
<div class="heading">Update</div><br />
<br />
I started testing this on 28 March 2013. The output of the 3 x AA batteries (pictured) was 3.973V.<br />
<br />
Five months later (1 September 2013) the output is 3.826V. Judging by the battery datasheet, once the voltage drops below 1.2V (per cell) then the batteries are pretty-much flat. <br />
<br />
<img src="/images/Arduino/Battery_discharge_11497.png"><br />
<br />
So that is 3.6V for the three of them. Since we are still at 3.83V it would appear that it has a while to go yet.<br />
<br />
And since (in this test) the temperature in this room if often outside the set range, the test includes the LED flashing a lot of the time.<br />
<br />
<div class="heading">Update a year later</div><br />
<br />
Over a year later (506 days) on 16 August 2014, the gadget is still working, flashing the blue light on cold mornings, and the red light as the day warms up.<br />
<br />
The combined battery voltage is now 3.227 V which is 1.075 V per cell. Whilst it is clearly dropping slowly, I am surprised that it is still working at all, as we are now below the voltage where you might expect the batteries to quickly discharge, to say nothing of the fact that rechargeable NiMh batteries are not known for keeping charged for a long time.<br />
<br />
This appears to demonstrate that the basic design could be used in situations where you only change (or charge) the batteries once per year, and have some confidence it will keep working all that time.</td></tr><tr><td><hr >
<font size=1 color="#808080">- Nick Gammon<br />
<br />
www.gammon.com.au, www.mushclient.com</font></td></tr><tr align=right><td><font size=1><a href="#top"><img src="/images/gototop.gif" alt="[Go to top]" width=15 height=15 border=0>&nbsp;top</a> </font></td></tr></table>
</div></td>
  </tr>
</table>
<hr>
<a name="reply6"></a><a name="73678"></a>
<table border=0 cellpadding=5 width="100%">
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Posted by</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><b>Nick Gammon</b></a>
<font size=1>&nbsp;&nbsp;Australia</font>&nbsp;&nbsp;<font size=1>(21,244 posts)</font>&nbsp;&nbsp;<font size=1><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><img src="/images/bio.gif" border=0 width=15 height=15 alt="[Biography]">&nbsp;bio</a>
</font>&nbsp;&nbsp;<font size=1><i>Forum Administrator</i></font></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Date</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/?id=11497&reply=6#reply6">Reply #6</a> on Sat 12 Oct 2013 05:08 AM (UTC)<p><font size=1>Amended on Sat 12 Oct 2013 07:37 AM (UTC) by <a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank">Nick Gammon</a>
</font></p></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Message</b></td>
    <td bgcolor="#FAF0E6" align=left><div class=postbody><table width="100%"><tr><td>The code below demonstrates doing both pin change interrupts, and a watchdog timer interrupt, for the ATtiny 85 family.<br />
<br />
This example has an LED on D3 (pin 2 on the chip) and a wake-up button on D4 (pin 3 on the chip). It also wakes up roughly every 8 seconds, which you could use to check if something needed to be done.<br />
<br />
See <a href="http://www.gammon.com.au/forum/?id=11488&amp;reply=9#reply9">http://www.gammon.com.au/forum/?id=11488&amp;reply=9#reply9</a> for similar code without the watchdog timer. That code (which only responds to a switch) uses a mere 500 nA of power.<br />
<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
// ATtiny85 sleep mode, wake on pin change interrupt or watchdog timer
// Author: Nick Gammon
// Date: 12 October 2013

// ATMEL ATTINY 25/45/85 / ARDUINO
//
//                  +-\/-+
// Ain0 (D 5) PB5  1|    |8  Vcc
// Ain3 (D 3) PB3  2|    |7  PB2 (D 2) Ain1
// Ain2 (D 4) PB4  3|    |6  PB1 (D 1) pwm1
//            GND  4|    |5  PB0 (D 0) pwm0
//                  +----+

#include &lt;avr/sleep.h&gt;    // Sleep Modes
#include &lt;avr/power.h&gt;    // Power management
#include &lt;avr/wdt.h&gt;      // Watchdog timer

const byte LED = 3;  // pin 2
const byte SWITCH = 4; // pin 3 / PCINT4

ISR (PCINT0_vect) 
 {
 // do something interesting here
 }  // end of PCINT0_vect
 
// watchdog interrupt
ISR (WDT_vect) 
{
   wdt_disable();  // disable watchdog
}  // end of WDT_vect

void resetWatchdog ()
  {
  // clear various &quot;reset&quot; flags
  MCUSR = 0;     
  // allow changes, disable reset, clear existing interrupt
  WDTCR = bit (WDCE) | bit (WDE) | bit (WDIF);
  // set interrupt mode and an interval (WDE must be changed from 1 to 0 here)
  WDTCR = bit (WDIE) | bit (WDP3) | bit (WDP0);    // set WDIE, and 8 seconds delay
  // pat the dog
  wdt_reset();  
  }  // end of resetWatchdog
  
void setup ()
  {
  resetWatchdog ();  // do this first in case WDT fires
  
  pinMode (LED, OUTPUT);
  pinMode (SWITCH, INPUT);
  digitalWrite (SWITCH, HIGH);  // internal pull-up
  
  // pin change interrupt (example for D4)
  PCMSK  = bit (PCINT4);  // want pin D4 / pin 3
  GIFR  |= bit (PCIF);    // clear any outstanding interrupts
  GIMSK |= bit (PCIE);    // enable pin change interrupts 
  }  // end of setup

void loop ()
  {
  digitalWrite (LED, HIGH);
  delay (500); 
  digitalWrite (LED, LOW);
  delay (500); 
  goToSleep ();
  }  // end of loop
  
void goToSleep ()
  {
  set_sleep_mode (SLEEP_MODE_PWR_DOWN);
  ADCSRA = 0;            // turn off ADC
  power_all_disable ();  // power off ADC, Timer 0 and 1, serial interface
  noInterrupts ();       // timed sequence coming up
  resetWatchdog ();      // get watchdog ready
  sleep_enable ();       // ready to sleep
  interrupts ();         // interrupts are required now
  sleep_cpu ();          // sleep                
  sleep_disable ();      // precaution
  power_all_enable ();   // power everything back on
  }  // end of goToSleep 
</code></pre></span></div><br />
<br />
Power consumption when asleep (but with watchdog timer enabled): 6.66 &micro;A.<br />
<br />
This agrees with the datasheet:<br />
<br />
<img src="/images/Arduino/Arduino_forum_192888.png"></td></tr><tr><td><hr >
<font size=1 color="#808080">- Nick Gammon<br />
<br />
www.gammon.com.au, www.mushclient.com</font></td></tr><tr align=right><td><font size=1><a href="#top"><img src="/images/gototop.gif" alt="[Go to top]" width=15 height=15 border=0>&nbsp;top</a> </font></td></tr></table>
</div></td>
  </tr>
</table>
<hr>
<a name="reply7"></a><a name="75935"></a>
<table border=0 cellpadding=5 width="100%">
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Posted by</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><b>Nick Gammon</b></a>
<font size=1>&nbsp;&nbsp;Australia</font>&nbsp;&nbsp;<font size=1>(21,244 posts)</font>&nbsp;&nbsp;<font size=1><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><img src="/images/bio.gif" border=0 width=15 height=15 alt="[Biography]">&nbsp;bio</a>
</font>&nbsp;&nbsp;<font size=1><i>Forum Administrator</i></font></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Date</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/?id=11497&reply=7#reply7">Reply #7</a> on Sun 07 Dec 2014 04:47 AM (UTC)<p><font size=1>Amended on Fri 16 Jan 2015 02:35 AM (UTC) by <a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank">Nick Gammon</a>
</font></p></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Message</b></td>
    <td bgcolor="#FAF0E6" align=left><div class=postbody><table width="100%"><tr><td><div class="heading">Altering the processor frequency</div><br />
<br />
A simple method of changing the clock frequency is to alter the clock prescaler in code.<br />
<br />
You can do this by doing two writes to the CLKPR register, as shown below. You must turn interrupts off because this is a timed sequence. The first write enables changing the speed. The second write writes a new prescaler from the list:<br />
<br />
<br /><ul>
<li>clock_div_1<br />
<li>clock_div_2<br />
<li>clock_div_4<br />
<li>clock_div_8<br />
<li>clock_div_16<br />
<li>clock_div_32<br />
<li>clock_div_64<br />
<li>clock_div_128<br />
<li>clock_div_256<br />
</ul><br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
#include &lt;avr/power.h&gt;

void setup ()
  {
  noInterrupts ();
  CLKPR = bit (CLKPCE);
  CLKPR = <b>clock_div_256</b>;
  interrupts ();
  
  // disable ADC
  ADCSRA = 0;  
  power_all_disable ();
  } // end of setup
 
void loop () { }
</code></pre></span></div><br />
<br />
The default is normally &quot;divide by one&quot; unless the &quot;divide clock by 8&quot; (CKDIV8) fuse is set. In any case, you can change to one of the other prescalers. If you are running from low voltages you may wish to set the &quot;divide by 8&quot; fuse, even if you are eventually planning to only divide by 4.<br />
<br />
Testing at 3.3V power, I measured the following results:<br />
<br />
<br /><ul>
<li>clock_div_1 - 3.1 mA<br />
<li>clock_div_2 - 1.8 mA<br />
<li>clock_div_4 - 1.1 mA<br />
<li>clock_div_8 - 750 &micro;A<br />
<li>clock_div_16 - 550 &micro;A<br />
<li>clock_div_32 - 393 &micro;A<br />
<li>clock_div_64 - 351 &micro;A<br />
<li>clock_div_128 - 296 &micro;A<br />
<li>clock_div_256 - 288 &micro;A<br />
</ul><br />
<br />
And then since running at &quot;divided by 256&quot; lets you run at low voltages, I tested dropping the voltage to 1.8V, and got 160 &micro;A consumption.<br />
<br />
This is, of course, before using any sleep modes. This demonstrates that you can get quite low power consumption, with the processor not asleep, by just playing with the clock prescaler.<br />
<br />
Of course, once you change the prescaler, all timings will be out by that factor. For example, if you divide by 2, then serial communications will operate at half the specified baud rate. And if you do a delay(100) it will actually delay for 200 mS.<br />
<br />
<hr/><br />
<br />
Shorter alternative, using a macro from power.h:<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
#include &lt;avr/power.h&gt;

void setup ()
  {
  // slow clock to divide by 256
  <b>clock_prescale_set (clock_div_256);</b>
  
  // disable ADC
  ADCSRA = 0;  
  power_all_disable ();
  } // end of setup
 
void loop () { }
</code></pre></span></div></td></tr><tr><td><hr >
<font size=1 color="#808080">- Nick Gammon<br />
<br />
www.gammon.com.au, www.mushclient.com</font></td></tr><tr align=right><td><font size=1><a href="#top"><img src="/images/gototop.gif" alt="[Go to top]" width=15 height=15 border=0>&nbsp;top</a> </font></td></tr></table>
</div></td>
  </tr>
</table>
<hr>
<a name="reply8"></a><a name="77182"></a>
<table border=0 cellpadding=5 width="100%">
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Posted by</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><b>Nick Gammon</b></a>
<font size=1>&nbsp;&nbsp;Australia</font>&nbsp;&nbsp;<font size=1>(21,244 posts)</font>&nbsp;&nbsp;<font size=1><a href="//www.gammon.com.au/forum/bbshowbio.php?bbuser_id=1" target="_blank"><img src="/images/bio.gif" border=0 width=15 height=15 alt="[Biography]">&nbsp;bio</a>
</font>&nbsp;&nbsp;<font size=1><i>Forum Administrator</i></font></td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Date</b></td>
    <td bgcolor="#FAF0E6" align=left><a href="//www.gammon.com.au/forum/?id=11497&reply=8#reply8">Reply #8</a> on Tue 07 Jul 2015 02:50 AM (UTC)</td>
  </tr>
  <tr valign="top">
    <td valign=top bgcolor="#ADD8E6" align=right width="10%"><b>Message</b></td>
    <td bgcolor="#FAF0E6" align=left><div class=postbody><table width="100%"><tr><td><div class="heading">Waking Serial from sleep</div><br />
<br />
Similar to the earlier reply (reply #1) about waking I2C from sleep, the sketch below uses a pin-change interrupt to wake the processor from sleep when it receives incoming serial data on the Rx pin (D0).<br />
<br />
This particular sketch sleeps if there is no input for 5 seconds. Incoming serial data awakes it. However because the incoming byte that wakes the sketch up has already arrived by the time the processor powers up, you should send a dummy &quot;wake up!&quot; message, pause a couple of milliseconds, then send the &quot;real&quot; message. That way the processor has a chance to get ready.<br />
<br />
You would want validation built into your code (eg. sumchecks) to avoid processing spurious data.<br />
<br />
<div class="codetag"><span class="notranslate"><pre><code>
#include &lt;avr/sleep.h&gt;
#include &lt;avr/power.h&gt;

const byte AWAKE_LED = 8;
const byte GREEN_LED = 9;
const unsigned long WAIT_TIME = 5000;

ISR (PCINT2_vect)
{
  // handle pin change interrupt for D0 to D7 here
}  // end of PCINT2_vect

void setup() 
{
  pinMode (GREEN_LED, OUTPUT);
  pinMode (AWAKE_LED, OUTPUT);
  digitalWrite (AWAKE_LED, HIGH);
  Serial.begin (9600);
} // end of setup

unsigned long lastSleep;

void loop() 
{
  if (millis () - lastSleep &gt;= WAIT_TIME)
  {
    lastSleep = millis ();

    noInterrupts ();

    byte old_ADCSRA = ADCSRA;
    // disable ADC
    ADCSRA = 0;  
    // pin change interrupt (example for D0)
    PCMSK2 |= bit (PCINT16); // want pin 0
    PCIFR  |= bit (PCIF2);   // clear any outstanding interrupts
    PCICR  |= bit (PCIE2);   // enable pin change interrupts for D0 to D7

    set_sleep_mode (SLEEP_MODE_PWR_DOWN);  
    power_adc_disable();
    power_spi_disable();
    power_timer0_disable();
    power_timer1_disable();
    power_timer2_disable();
    power_twi_disable();

    UCSR0B &amp;= ~bit (RXEN0);  // disable receiver
    UCSR0B &amp;= ~bit (TXEN0);  // disable transmitter

    sleep_enable();
    digitalWrite (AWAKE_LED, LOW);
    interrupts ();
    sleep_cpu ();      
    digitalWrite (AWAKE_LED, HIGH);
    sleep_disable();
    power_all_enable();

    ADCSRA = old_ADCSRA;
    PCICR  &amp;= ~bit (PCIE2);   // disable pin change interrupts for D0 to D7
    UCSR0B |= bit (RXEN0);  // enable receiver
    UCSR0B |= bit (TXEN0);  // enable transmitter
  }  // end of time to sleep

  if (Serial.available () &gt; 0)
  {
    byte flashes = Serial.read () - &#039;0&#039;;
    if (flashes &gt; 0 &amp;&amp; flashes &lt; 10)
      {
      // flash LED x times 
      for (byte i = 0; i &lt; flashes; i++)
        {
        digitalWrite (GREEN_LED, HIGH);
        delay (200);  
        digitalWrite (GREEN_LED, LOW);
        delay (200);  
        }
      }        
  }  // end of if

}  // end of loop
</code></pre></span></div><br />
<br />
<br />
I have a couple of LEDs there - the &quot;green&quot; one on pin D9 flashes the appropriate number of times. Also there is an &quot;awake&quot; LED which helps debug whether the processor is asleep or awake.<br />
<br />
Whilst asleep, I measured about 120 nA (0.120 &micro;A) of current drawn.</td></tr><tr><td><hr >
<font size=1 color="#808080">- Nick Gammon<br />
<br />
www.gammon.com.au, www.mushclient.com</font></td></tr><tr align=right><td><font size=1><a href="#top"><img src="/images/gototop.gif" alt="[Go to top]" width=15 height=15 border=0>&nbsp;top</a> </font></td></tr></table>
</div></td>
  </tr>
</table>
<hr>
<p><font size=1>
The dates and times for posts above are shown in Universal Co-ordinated Time (UTC).</font></p>
<p><font size=1>To show them in your local time you can join the forum, and then set the 'time correction' field in your profile to the number of hours difference between your location and UTC time.</font></p>
<hr>
<p><font size=1>284,614 views.</font></p>
<p>
<p><b>Postings by administrators only.</b></p>
<a href="//www.gammon.com.au/forum/bbshowpost.php?bbsubject_id=11497&amp;page=1" rel="nofollow"><img src="/images/refresh.gif" alt="[Refresh]" width="13" height="16" border="0"/>&nbsp;Refresh page</a>
</p><form METHOD="post" ACTION="//www.gammon.com.au/forum/bbshowpost.php"> 
<p>Go to topic: &nbsp; <select name="bbtopic_id" size=1>
<option value=0 selected>(Choose topic)
<option value="17">Area Editor: Bug reports
<option value="18">Area Editor: General
<option value="19">Area Editor: News and updates
<option value="20">Area Editor: Suggestions
<option value="21">Area Editor: Tips and tricks
<option value="104">Dawn of Time: Administration
<option value="103">Dawn of Time: Configuration
<option value="102">Dawn of Time: Installing/compiling the server
<option value="109">Dawn of Time: New Dawn Muds Announcements
<option value="105">Dawn of Time: Playing
<option value="101">Dawn of Time: What is Dawn of Time (Dawn)?
<option value="123">Electronics: Microprocessors
<option value="124">Electronics: Operational Amplifiers
<option value="11">Forum: About
<option value="35">Forum: Announcements
<option value="26">Forum: Mailing other users
<option value="12">Forum: Problems
<option value="14">Forum: Registering
<option value="13">Forum: Searching
<option value="15">Forum: Subscribing
<option value="106">Forum: Suggestions
<option value="16">Forum: Test
<option value="30">Forum: Time zones / time display
<option value="32">Forum software: Administration
<option value="31">Forum software: Installation
<option value="34">MUDs: Announcements
<option value="27">MUDs: General
<option value="116">MUDs: MUD Design Concepts
<option value="1">MUSHclient: Announcements
<option value="107">MUSHclient: Beta testing
<option value="5">MUSHclient: Bug reports
<option value="122">MUSHclient: Development
<option value="7">MUSHclient: General
<option value="120">MUSHclient: Getting Started
<option value="118">MUSHclient: International
<option value="3">MUSHclient: Jscript
<option value="113">MUSHclient: Lua
<option value="121">MUSHclient: Miniwindows
<option value="33">MUSHclient: MXP and Pueblo
<option value="4">MUSHclient: Perlscript
<option value="108">MUSHclient: Plugins
<option value="110">MUSHclient: Python
<option value="6">MUSHclient: Suggestions
<option value="8">MUSHclient: Tips and tricks
<option value="2">MUSHclient: VBscript
<option value="117">MUSHclient: Wine
<option value="22">PennMUSH: Compiling the server
<option value="23">PennMUSH: Running the server
<option value="112">Programming: General
<option value="111">Programming: STL
<option value="114">Quilting: General
<option value="28">ROM: Compiling the server
<option value="29">ROM: Running the server
<option value="115">SMAUG: Commands
<option value="24">SMAUG: Compiling the server
<option value="119">SMAUG: Lua
<option value="25">SMAUG: Running the server
<option value="36">SMAUG: SMAUG coding
</select>
&nbsp; &nbsp; <input Type=submit Value="Go">&nbsp; &nbsp;
<a href="//www.gammon.com.au/forum/bbsearch.php">Search the forum</a>
</p></form>
<hr>
<p align=right><font size=1><a href="#top"><img src="/images/gototop.gif" alt="[Go to top]" width=15 height=15 border=0>&nbsp;top</a></font></p>
<p style="font-size:x-small;">
<i>Quick links:</i>
<a href="/mushclient/mushclient.htm"><b>MUSHclient</b></a>.
MUSHclient <a href="/scripts/doc.php"><b>help</b></a>.
Forum <a href="/shortcuts"><b>shortcuts</b></a>. 
Posting <a href="/templates"><b>templates</b></a>.
Lua <a href="/modules"><b>modules</b></a>.
Lua <a href="/luahelp"><b>documentation</b></a>.
</p>
<p style="font-size:x-small;" >Information and images on this site are licensed under the <a rel="license" href="https://creativecommons.org/licenses/by/3.0/au/">Creative Commons Attribution 3.0 Australia License</a> unless stated otherwise.
<p><a href="/welcome.html">
<img src="/images/home.gif" border=0 width=95 height=27 alt="[Home]"></a>

</div>   <!-- end of indented div -->

<hr>
<p>
  <a href="/">
  <IMG SRC="/images/NickGammon.gif"
          alt="Written by Nick Gammon - 5K" 
          title="Written by Nick Gammon"
          width=224 height=30></a>

&nbsp;

<!-- StackExchange profile -->

<a href="https://stackexchange.com/users/6511685">
<img src="https://stackexchange.com/users/flair/6511685.png" width="208" height="58" alt="profile for Nick Gammon on Stack Exchange, a network of free, community-driven Q&amp;A sites" title="profile for Nick Gammon on Stack Exchange, a network of free, community-driven Q&amp;A sites"></a>

&nbsp;

<a href="https://en.wikipedia.org/wiki/Same-sex_marriage"><img src="/images/rainbowflag.png" 
alt="Marriage equality" title="Marriage equality"
style=" box-shadow: 3px 3px 3px #666666;"
></a>

  </p>
<p>
Comments to: 
<a href="/support/">Gammon Software support</a>
<br>
<a href="/rss/forum.xml"><img src="/images/xml.gif" alt="[RH click to get RSS URL]" width=36 height=14 border=0 ></a> 
<a type="application/rss+xml" href="/rss/forum.xml">Forum RSS feed</a> <font size=1>( https://gammon.com.au/rss/forum.xml )</font>
</p>



<p> 
<a href="https://www.anybrowser.org/"> 
<img src="/images/anybrowser2.gif" alt="[Best viewed with any browser - 2K]" width=88 height=31 border=0 title="Best viewed with any browser"></a> 
&nbsp;&nbsp;

<a href="https://www.FutureQuest.net"><img src="/images/futurequest.gif"
   alt="[Hosted at FutureQuest]" title="Hosted at FutureQuest"> </a>


</p>

</body>
</html>